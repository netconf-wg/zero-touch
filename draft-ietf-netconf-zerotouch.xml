<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<!--<?rfc strict="no"?> -->

<rfc category="std"
     ipr="trust200902"
     docName="draft-ietf-netconf-zerotouch-latest">
    <front>
        <title abbrev="Secure Zero Touch Provisioning (SZTP)">Secure Zero Touch Provisioning (SZTP)</title>
        <author initials="K.W." surname="Watsen" fullname="Kent Watsen">
            <organization>Juniper Networks</organization>
            <address>
                <email>kwatsen@juniper.net</email>
            </address>
        </author>
        <author initials="M.A." surname="Abrahamsson" fullname="Mikael Abrahamsson">
            <organization>T-Systems</organization>
            <address>
                <email>mikael.abrahamsson@t-systems.se</email>
            </address>
        </author>
        <author initials="I.F." surname="Farrer" fullname="Ian Farrer">
            <organization>Deutsche Telekom AG</organization>
            <address>
                <email>ian.farrer@telekom.de</email>
            </address>
        </author>
        <date/>
        <area>Operations</area>
        <workgroup>NETCONF Working Group</workgroup>
        <keyword>zerotouch</keyword>
        <keyword>bootstrap</keyword>
        <keyword>sztp</keyword>
        <keyword>ztp</keyword>
        <abstract>
            <t>This draft presents a technique to securely provision a networking
            device when it is booting in a factory-default state.  Variations
            in the solution enables it to be used on both public and private
            networks.  The provisioning steps are able to update the boot image,
            commit an initial configuration, and execute arbitrary scripts to
            address auxiliary needs.  The updated device is subsequently able
            to establish secure connections with other systems.  For instance,
            a device may establish NETCONF (RFC 6241) and/or RESTCONF (RFC 8040)
            connections with deployment-specific network management systems.</t>
        </abstract>
        <note title="Editorial Note (To be removed by RFC Editor)">
          <t>This draft contains many placeholder values that need to be replaced
          with finalized values at the time of publication.  This note summarizes
          all of the substitutions that are needed.  No other
          RFC Editor instructions are specified elsewhere in this document.</t>
          <t>Artwork in the IANA Considerations section contains placeholder
          values for DHCP options pending IANA assignment.  Please apply the
          following replacements:
            <list  style="symbols">
              <t><spanx style="verb">TBD1</spanx> --&gt; the assigned value for id-ct-sztpConveyedInfoXML</t>
              <t><spanx style="verb">TBD2</spanx> --&gt; the assigned value for id-ct-sztpConveyedInfoJSON</t>
            </list>
          </t>
          <t>Artwork in this document contains shorthand references to drafts in
          progress.  Please apply the following replacements:
            <list  style="symbols">
              <t><spanx style="verb">XXXX</spanx> --&gt; the assigned numerical RFC value for this draft</t>
            </list>
          </t>
          <t>Artwork in this document contains placeholder values for the date of publication of this
          draft.  Please apply the following replacement:
            <list  style="symbols">
              <t><spanx style="verb">YYYY-MM-DD</spanx> --&gt; the publication date of this draft</t>
            </list>
          </t>
          <t>The following one Appendix section is to be removed prior to publication:
            <list  style="symbols">
              <t>Appendix D.  Change Log</t>
            </list>
          </t>
        </note>
    </front>

    <middle>
      <section title="Introduction">

        <t>A fundamental business requirement for any network operator is
        to reduce costs where possible.  For network operators, deploying
        devices to many locations can be a significant cost, as sending
        trained specialists to each site for installations is both cost
        prohibitive and does not scale.</t>

        <t>This document defines Secure Zero Touch Provisioning (SZTP),
        a bootstrapping strategy enabling devices to securely obtain
        bootstrapping data with no installer action beyond physical
        placement and connecting network and power cables.  As such,
        SZTP enables non-technical personnel to bring up devices in
        remote locations without the need for any operator input.</t>

        <t>The SZTP solution includes updating the boot image,
        committing an initial configuration, and executing arbitrary scripts to
        address auxiliary needs.  The updated device is subsequently able to
        establish secure connections with other systems.  For instance, a
        devices may establish NETCONF <xref target="RFC8040"/> and/or RESTCONF
        <xref target="RFC6241"/> connections with deployment-specific network
        management systems.</t>

        <t>This document primarily regards physical devices, where the setting
        of the device's initial state, described in <xref target="initial-state"/>,
        occurs during the device's manufacturing process.  The SZTP solution
        may be extended to support virtual machines or other such logical
        constructs, but details for how this can be accomplished is left
        for future work.</t>


        <section title="Use Cases" anchor="use-cases">
          <t>
            <list style="symbols">
              <t>Device connecting to a remotely administered network
                <list style="empty">
                  <t>This use-case involves scenarios, such as a remote branch office
                  or convenience store, whereby a device connects as an access gateway
                  to an ISP's network.  Assuming it is not possible to customize the
                  ISP's network to provide any bootstrapping support, and with no other
                  nearby device to leverage, the device has no recourse but to reach
                  out to an Internet-based bootstrap server to bootstrap from.</t>
                </list>
              </t>
              <t>Device connecting to a locally administered network
                <list style="empty">
                  <t>This use-case covers all other scenarios and differs only in that
                  the device may additionally leverage nearby devices, which may direct
                  it to use a local service to bootstrap from.  If no such information
                  is available, or the device is unable to use the information provided,
                  it can then reach out to the network just as it would for the remotely
                  administered network use-case.</t>
                </list>
              </t>
            </list>
          </t>
          <t>Conceptual workflows for how SZTP might be deployed are
          provided in <xref target="workflow-overview"/>.</t>
        </section>


        <section title="Terminology" anchor="terminology">

          <t>This document uses the following terms (sorted by name):
            <list style="hanging" hangIndent="4">

              <t hangText="Artifact:">The term "artifact" is used throughout to represent
              any of the three artifacts defined in <xref target="artifacts"/> (conveyed
              information, ownership voucher, and owner certificate).  These artifacts
              collectively provide all the bootstrapping data a device may use.</t>

              <t hangText="Bootstrapping Data:">The term "bootstrapping data" is used
              throughout this document to refer to the collection of data that a device
              may obtain during the bootstrapping process.  Specifically, it refers
              to the three artifacts conveyed information, owner certificate, and
              ownership voucher, as described in <xref target="artifacts"/>. </t>

              <t hangText="Bootstrap Server:">The term "bootstrap server" is used within
              this document to mean any RESTCONF server implementing the YANG module
              defined in <xref target="yang-module"/>.</t>

              <t hangText="Conveyed Information:">The term "conveyed information" is used
              herein to refer either redirect information or onboarding information.
              Conveyed information is one of the three bootstrapping artifacts described in
              <xref target="artifacts"/>.</t>

              <t hangText="Device:">The term "device" is used throughout this document
              to refer to a network element that needs to be bootstrapped.  See
              <xref target="device-details"/> for more information about devices.</t>

              <t hangText="Manufacturer:">The term "manufacturer" is used herein to
              refer to the manufacturer of a device or a delegate of the manufacturer.</t>

              <t hangText="Network Management System (NMS):">The acronym "NMS" is used
              throughout this document to refer to the deployment-specific management
              system that the bootstrapping process is responsible for introducing devices to.
              From a device's perspective, when the bootstrapping process has completed,
              the NMS is a NETCONF or RESTCONF client.</t>

              <t hangText="Onboarding Information:">The term "onboarding information" is used
              herein to refer to one of the two types of "conveyed information"
              defined in this document, the other being "redirect information".  Onboarding
              information is formally defined by the "onboarding-information" YANG-data
              structure in <xref target="info-yang-module"/>.</t>

              <t hangText="Onboarding Server:">The term "onboarding server" is used
              herein to refer to a bootstrap server that only returns onboarding
              information.</t>

              <t hangText="Owner:">The term "owner" is used throughout this document
              to refer to the person or organization that purchased or otherwise owns
              a device.</t>

              <t hangText="Owner Certificate:">The term "owner certificate" is used in
              this document to represent an X.509 certificate that binds an owner identity
              to a public key, which a device can use to validate a signature over the
              conveyed information artifact.  The owner certificate may be communicated
              along with its chain of intermediate certificates leading up to a known
              trust anchor.  The owner certificate is one of the three bootstrapping
              artifacts described in <xref target="artifacts"/>.</t>

              <t hangText="Ownership Voucher:">The term "ownership voucher" is used in
              this document to represent the voucher artifact defined in <xref
              target="RFC8366"/>.  The ownership voucher is used to
              assign a device to an owner.  The ownership voucher is one of
              the three bootstrapping artifacts described in <xref target="artifacts"/>.</t>

              <t hangText="Redirect Information:">The term "redirect information" is used
              herein to refer to one of the two types of "conveyed information"
              defined in this document, the other being "onboarding information".  Redirect
              information is formally defined by the "redirect-information" YANG-data
              structure in <xref target="info-yang-module"/>.</t>

              <t hangText="Redirect Server:">The term "redirect server" is used to refer
              to a bootstrap server that only returns redirect information.  A redirect
              server is particularly useful when hosted by a manufacturer, as a
              well-known (e.g., Internet-based) resource to redirect devices to
              deployment-specific bootstrap servers.</t>

              <t hangText="Signed Data:">The term "signed data" is used throughout to mean
              conveyed information that has been signed, specifically by a private key
              possessed by a device's owner.</t>

              <t hangText="Unsigned Data:">The term "unsigned data" is used throughout to mean
              conveyed information that has not been signed.</t>
            </list>
          </t>
        </section>

        <section title="Requirements Language" anchor="requirements-language">
          <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
          "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
          when, and only when, they appear in all capitals, as shown here.</t>
        </section>

        <section title="Tree Diagrams">
          <t>Tree diagrams used in this document follow the notation
          defined in <xref target="RFC8340"/>.</t>
        </section>
      </section>  <!-- end Introduction -->


      <section title="Types of Conveyed Information" anchor="types-of-information">

        <t>This document defines two types of conveyed information that devices can access during
        the bootstrapping process.  These conveyed information types are described in
        this section. Examples are provided in <xref target="zt-info-data-model-examples"/></t>

        <section title="Redirect Information" anchor="redirect-information">
          <t>Redirect information redirects a device to
          another bootstrap server.  Redirect information encodes a list of bootstrap
          servers, each specifying the bootstrap server's hostname (or IP address),
          an optional port, and an optional trust anchor certificate that the device
          can use to authenticate the bootstrap server with.</t>

          <t>Redirect information is YANG modeled data formally defined by the
          "redirect-information" container in the YANG module presented in
          <xref target="info-yang-module"/>.  This container has the tree
          diagram shown below.</t>
          <t><figure>
            <artwork name="redirect-information-tree.txt"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/redirect-information-tree.txt)
]]></artwork>
          </figure></t>

          <t>Redirect information may be trusted or untrusted.  The redirect information
          is trusted whenever it is obtained via a secure connection to a trusted bootstrap
          server, or whenever it is signed by the device's owner.  In all other
          cases, the redirect information is untrusted.</t>

          <t>Trusted redirect information is useful for enabling a device to establish
          a secure connection to a specified bootstrap server, which is possible when the redirect
          information includes the bootstrap server's trust anchor certificate.</t>

          <t>Untrusted redirect information is useful for directing a device to a bootstrap
          server where signed data has been staged for it to obtain.  Note that, when the
          redirect information is untrusted, devices discard any potentially included trust
          anchor certificates.</t>

          <t>How devices process redirect information is described in
          <xref target="process-redirect-information"/>.</t>
        </section>

        <section title="Onboarding Information" anchor="onboarding-information">

          <t>Onboarding information provides data necessary for a device
          to bootstrap itself and establish secure connections with other
          systems.  As defined in this document, onboarding information can
          specify details about the boot image a device must be running, 
          specify an initial configuration the device must commit, and 
          specify scripts that the device must successfully execute.</t>

          <t>Onboarding information is YANG modeled data formally defined by the
          "onboarding-information" container in the YANG module presented in
          <xref target="info-yang-module"/>.  This container has the tree diagram
          shown below.</t>

         <t><figure>
            <artwork name="onboarding-information-tree.txt"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/onboarding-information-tree.txt)
]]></artwork>
          </figure></t>

          <t>Onboarding information must be trusted for it to be of any use to a device.
          There is no option for a device to process untrusted onboarding information.</t>

          <t>Onboarding information is trusted whenever it is obtained via a secure connection
          to a trusted bootstrap server, or whenever it is signed by the device's
          owner.  In all other cases, the onboarding information is untrusted.</t>

          <t>How devices process onboarding information is described in
          <xref target="process-onboarding-information"/>.</t>
        </section>

      </section>

      <section title="Artifacts" anchor="artifacts">

        <t>This document defines three artifacts that can be made available
        to devices while they are bootstrapping.  Each source of bootstrapping
        data specifies how it provides the artifacts defined in this section
        (see <xref target="sources"/>).</t>

        <section title="Conveyed Information" anchor="conveyed-information">
          <t>The conveyed information artifact encodes the essential bootstrapping
          data for the device.  This artifact is used to encode the redirect
          information and onboarding information types discussed in <xref
          target="types-of-information"/>.</t>

          <t>The conveyed information artifact is a CMS structure, as described
          in <xref target="RFC5652"/>, encoded using ASN.1 distinguished encoding
          rules (DER), as specified in ITU-T X.690 <xref target="ITU.X690.2015"/>.
          The CMS structure MUST contain content conforming to the
          YANG module specified in <xref target="info-yang-module"/>.</t>

          <t>The conveyed information CMS structure may encode signed or
          unsigned bootstrapping data.  When the bootstrapping data is signed,
          it may also be encrypted but, from a terminology perspective, it
          is still "signed data" <xref target="terminology"/>.</t>

          <t>When the conveyed information artifact is unsigned, as it might
          be when communicated over trusted channels, the CMS structure's 
          top-most content type MUST be one of the OIDs described in 
          <xref target="cms_cts"/> (i.e., id-ct-sztpConveyedInfoXML or
          id-ct-sztpConveyedInfoJSON), or the OID id-data (1.2.840.113549.1.7.1).
          When the OID id-data is used, the encoding (JSON, XML, etc.)
          SHOULD be communicated externally. In either case, the associated
          content is an octet string containing "conveyed-information"
          data in the expected encoding.</t>

          <t>When the conveyed information artifact is unsigned and 
          encrypted, as it might be when communicated over trusted
          channels but, for some reason, the operator wants to ensure
          that only the device is able to see the contents, the CMS 
          structure's top-most content type MUST be the OID id-envelopedData
          (1.2.840.113549.1.7.3). Furthermore, the encryptedContentInfo's
          content type MUST be one of the OIDs described in 
          <xref target="cms_cts"/> (i.e., id-ct-sztpConveyedInfoXML
          or id-ct-sztpConveyedInfoJSON), or the OID id-data
          (1.2.840.113549.1.7.1).  When the OID id-data is used,
          the encoding (JSON, XML, etc.) SHOULD be communicated
          externally. In either case, the associated content is
          an octet string containing "conveyed-information" data
          in the expected encoding.</t>

          <t>When the conveyed information artifact is signed, as it might
          be when communicated over untrusted channels, the CMS structure's
          top-most content type MUST be the OID id-signedData (1.2.840.113549.1.7.2).
          Furthermore, the inner eContentType MUST be one of the OIDs described in
          <xref target="cms_cts"/> (i.e., id-ct-sztpConveyedInfoXML or 
          id-ct-sztpConveyedInfoJSON), or the OID id-data (1.2.840.113549.1.7.1).
          When the OID id-data is used, the encoding (JSON, XML, etc.) SHOULD
          be communicated externally.  In either case, the associated content
          or eContent is an octet string containing "conveyed-information"
          data in the expected encoding.</t>

          <t>When the conveyed information artifact is signed and encrypted,
          as it might be when communicated over untrusted channels and 
          privacy is important, the CMS structure's top-most content type
          MUST be the OID id-envelopedData (1.2.840.113549.1.7.3). Furthermore, 
          the encryptedContentInfo's content type MUST be the OID id-signedData
          (1.2.840.113549.1.7.2), whose eContentType MUST be one of the OIDs
          described in <xref target="cms_cts"/> (i.e., id-ct-sztpConveyedInfoXML
          or id-ct-sztpConveyedInfoJSON), or the OID id-data
          (1.2.840.113549.1.7.1).  When the OID id-data is used, the encoding
          (JSON, XML, etc.) SHOULD be communicated externally.  In either case,
          the associated content or eContent is an octet string containing
          "conveyed-information" data in the expected encoding.</t>

        </section>

        <section title="Owner Certificate" anchor="owner-certificate">
          <t>The owner certificate artifact is an X.509 certificate
          <xref target="RFC5280"/> that is used to identify an "owner" (e.g.,
          an organization).  The owner certificate can be signed by any
          certificate authority (CA).  The owner certificate either MUST have
          no Key Usage specified or the Key Usage MUST at least set the
          "digitalSignature" bit.  The values for the owner certificate's
          "subject" and/or "subjectAltName" are not constrained by this
          document.</t>

          <t>The owner certificate is used by a device to verify the signature over
          the conveyed information artifact (<xref target="conveyed-information"/>)
          that the device should have also received, as described in
          <xref target="artifact-groupings"/>.  In particular, the device
          verifies the signature using the public key in the owner certificate
          over the content contained within the conveyed information artifact.</t>

          <t>The owner certificate artifact is formally a CMS structure, as
          specified by <xref target="RFC5652"/>, encoded using ASN.1
          distinguished encoding rules (DER), as specified in ITU-T X.690
          <xref target="ITU.X690.2015"/>.</t>

          <t>The owner certificate CMS structure MUST contain the owner
          certificate itself, as well as all intermediate certificates leading
          to the "pinned-domain-cert" certificate specified in the ownership
          voucher.  The owner certificate artifact MAY optionally include the
          "pinned-domain-cert" as well.</t>

          <t>In order to support devices deployed on private networks,
          the owner certificate CMS structure MAY also contain suitably fresh,
          as determined by local policy, revocation objects (e.g., CRLs).
          Having these revocation objects stapled to the owner certificate may
          obviate the need for the device to have to download them dynamically
          using the CRL distribution point or an OCSP responder specified in
          the associated certificates.</t>

          <t>When unencrypted, the owner certificate artifact's CMS structure's
          top-most content type MUST be the OID id-signedData (1.2.840.113549.1.7.2).
          The inner SignedData structure is the degenerate form, whereby there
          are no signers, that is commonly used to disseminate certificates and
          revocation objects.</t>

          <t>When encrypted, the owner certificate artifact's CMS structure's
          top-most content type MUST be the OID id-envelopedData 
          (1.2.840.113549.1.7.3), and the encryptedContentInfo's content type
          MUST be the OID id-signedData (1.2.840.113549.1.7.2), whereby the
          inner SignedData structure is the degenerate form that has no signers
          commonly used to disseminate certificates and revocation objects.</t>

        </section>

        <section title="Ownership Voucher" anchor="ownership-voucher">
          <t>The ownership voucher artifact is used to securely identify a device's
          owner, as it is known to the manufacturer.  The ownership voucher is signed
          by the device's manufacturer.</t>

          <t>The ownership voucher is used to verify the owner certificate
          (<xref target="owner-certificate"/>) that the device should have also
          received, as described in <xref target="artifact-groupings"/>.  In
          particular, the device verifies that the owner certificate has a chain
          of trust leading to the trusted certificate included in the ownership
          voucher ("pinned-domain-cert").  Note that this relationship holds
          even when the owner certificate is a self-signed certificate, and
          hence also the pinned-domain-cert.</t>

          <t>When unencrypted, the ownership voucher artifact is as defined
          in <xref target="RFC8366"/>.  As described, it is
          a CMS structure whose top-most content type MUST be the OID 
          id-signedData (1.2.840.113549.1.7.2), whose eContentType MUST
          be OID id-ct-animaJSONVoucher (1.2.840.113549.1.9.16.1), or the
          OID id-data (1.2.840.113549.1.7.1).  When the OID id-data is used,
          the encoding (JSON, XML, etc.) SHOULD be communicated externally.
          In either case, the associated content is an octet string
          containing ietf-voucher data in the expected encoding.</t>

          <t>When encrypted, the ownership voucher artifact's CMS structure's
          top-most content type MUST be the OID id-envelopedData 
          (1.2.840.113549.1.7.3), and the encryptedContentInfo's content type
          MUST be the OID id-signedData (1.2.840.113549.1.7.2), whose eContentType
          MUST be OID id-ct-animaJSONVoucher (1.2.840.113549.1.9.16.1), or the OID
          id-data (1.2.840.113549.1.7.1).  When the OID id-data is used, the
          encoding (JSON, XML, etc.) SHOULD be communicated externally.  In
          either case, the associated content is an octet string containing
          ietf-voucher data in the expected encoding.</t>
        </section>

        <section title="Artifact Encryption" anchor="artifact-encryption">
          <t>Each of the three artifacts MAY be individually encrypted.  Encryption
          may be important in some environments where the content is considered
          sensitive.</t>
          <t>Each of the three artifacts are encrypted in the same way, by the
          unencrypted form being encapsulated inside a CMS EnvelopedData type.</t>
          <t>As a consequence, both the conveyed information and ownership
          voucher artifacts are signed and then encrypted, never encrypted
          and then signed.</t>
          <t>This sequencing has the advantage of shrouding the signer's
          certificate, and ensuring that the owner knows the content being
          signed.  This sequencing further enables the owner to inspect an
          unencrypted voucher obtained from a manufacturer and then encrypt
          the voucher later themselves, perhaps while also stapling in 
          current revocation objects, when ready to place the artifact
          in an unsafe location.</t>
          <t>When encrypted, the CMS MUST be encrypted using a secure device
          identity certificate for the device.  This certificate MAY be the
          same as the TLS-level client certificate the device uses when
          connecting to bootstrap servers.  The owner must possess the
          device's identity certificate at the time of encrypting the data.
          How the owner comes to posses the device's identity certificate
          for this purpose is outside the scope of this document.</t>
        </section>

        <section title="Artifact Groupings" anchor="artifact-groupings">
          <t>The previous sections discussed the bootstrapping artifacts,
          but only certain groupings of these artifacts make sense to return in the
          various bootstrapping situations described in this document.  These groupings
          are:
            <list style="hanging" hangIndent="6">
                <t hangText="   Unsigned Data:">This artifact grouping is useful for cases
                  when transport level security can be used to convey trust (e.g., HTTPS),
                  or when the conveyed information can be processed in a provisional manner (i.e.
                  unsigned redirect information).</t>
                <t hangText="   Signed Data, without revocations:">This artifact grouping
                  is useful when signed data is needed (i.e., because the data is obtained
                  from an untrusted source and it cannot be processed provisionally)
                  and either revocations are not needed or the revocations can be obtained
                  dynamically.</t>
                <t hangText="   Signed Data, with revocations:">This artifact grouping
                  is useful when signed data is needed (i.e., because the data is obtained
                  from an untrusted source and it cannot be processed provisionally), and
                  revocations are needed, and the revocations cannot be obtained dynamically.</t>
            </list>
          </t>
          <t>The presence of each artifact, and any distinguishing characteristics, are identified
             for each artifact grouping in the table below ("yes/no" regards if the
              artifact is present in the artifact grouping):
            <figure>
              <artwork><![CDATA[
+---------------------+---------------+--------------+--------------+
| Artifact            | Conveyed      | Ownership    | Owner        |
| Grouping            | Information   | Voucher      | Certificate  |
+=====================+===============+==============+==============+
| Unsigned Data       | Yes, no sig   | No           | No           |
+---------------------+---------------+--------------+--------------+
| Signed Data,        | Yes, with sig | Yes, without | Yes, without |
| without revocations |               | revocations  | revocations  |
+---------------------+---------------+--------------+--------------+
| Signed Data,        | Yes, with sig | Yes, with    | Yes, with    |
| with revocations    |               | revocations  | revocations  |
+---------------------+---------------+--------------+--------------+
  ]]></artwork>
            </figure>
          </t>
        </section>
      </section>

      <section title="Sources of Bootstrapping Data" anchor="sources">

        <t>This section defines some sources for bootstrapping data that a device
        can access.  The list of sources defined here is not meant to be exhaustive.
        It is left to future documents to define additional sources for obtaining
        bootstrapping data.</t>

        <t>For each source of bootstrapping data defined in this section, details
        are given for how the three artifacts listed in <xref target="artifacts"/>
        are provided.</t>

        <section title="Removable Storage" anchor="removable-storage">
          <t>A directly attached removable storage device (e.g., a USB flash drive)
          MAY be used as a source of SZTP bootstrapping data.</t>

          <t>Use of a removable storage device is compelling, as it does not require
          any external infrastructure to work.  It is notable that the raw boot
          image file can also be located on the removable storage device, enabling
          a removable storage device to be a fully self-standing bootstrapping
          solution.</t>

          <t>To use a removable storage device as a source of bootstrapping data,
          a device need only detect if the removable storage device is plugged in
          and mount its filesystem.</t>

          <t>A removable storage device is an untrusted source of bootstrapping data.
          This means that the information stored on the removable storage device
          either MUST be signed or MUST be information that can be processed
          provisionally (e.g., unsigned redirect information).</t>

          <t>From an artifact perspective, since a removable storage device presents
          itself as a filesystem, the bootstrapping artifacts need to be presented
          as files.  The three artifacts defined in <xref target="artifacts"/> are
          mapped to files below.</t>

          <t>Artifact to File Mapping:
            <list style="hanging" hangIndent="6">
              <t hangText="   Conveyed Information:">Mapped to a file containing
              the binary artifact described in <xref target="conveyed-information"/>
              (e.g., conveyed-information.cms).</t>
              <t hangText="   Owner Certificate:">Mapped to a file containing the
              binary artifact described in <xref target="owner-certificate"/>
              (e.g., owner-certificate.cms).</t>
              <t hangText="   Ownership Voucher:">Mapped to a file containing the
              binary artifact described in <xref target="ownership-voucher"/>
              (e.g., ownership-voucher.cms or ownership-voucher.vcj).</t>
            </list>
          </t>
          <t>The format of the removable storage device's filesystem and the naming of the
          files are outside the scope of this document.  However, in order to facilitate
          interoperability, it is RECOMMENDED devices support open and/or standards based
          filesystems.  It is also RECOMMENDED that devices assume a file naming convention
          that enables more than one instance of bootstrapping data (i.e., for different
          devices) to exist on a removable storage device.  The file naming convention 
          SHOULD additionally be unique to the manufacturer, in order to enable bootstrapping
          data from multiple manufacturers to exist on a removable storage device.</t>
        </section>

        <section title="DNS Server" anchor="dns-server">
          <t>A DNS server MAY be used as a source of SZTP bootstrapping data.</t>

          <t>Using a DNS server may be a compelling option for deployments having
          existing DNS infrastructure, as it enables a touchless bootstrapping option
          that does not entail utilizing an Internet based resource hosted by a
          3rd-party.</t>

          <t>DNS is an untrusted source of bootstrapping data.  Even if DNSSEC
          <xref target="RFC6698"/> is used to authenticate the various DNS resource
          records (e.g., A, AAAA, CERT, TXT, and TLSA), the device cannot be
          sure that the domain returned to it from e.g., a DHCP server, belongs
          to its rightful owner.  This means that the information stored in the
          DNS records either MUST be signed (per this document, not DNSSEC), or
          MUST be information that can be processed provisionally (e.g., unsigned
          redirect information).</t>

          <section title="DNS Queries" toc="exclude">

            <t>Devices claiming to support DNS as a source of bootstrapping
            data MUST first query for device-specific DNS records using DNS-SD
            <xref target="RFC6763"/> and, only if doing so does not result in a
            successful bootstrap, then query for device-independent records
            using traditional service discovery <xref target="RFC2782"/>.
            Furthermore, when issuing the device-specific and device-independent
            queries, devices MUST first query using multicast DNS <xref target="RFC6762"/>
            and, only if doing so does not result in a successful bootstrap, then
            query again using unicast DNS <xref target="RFC1035"/><xref target="RFC7766"/>,
            assuming the address of a DNS server is known.</t>
  
            <t>When querying for device-specific DNS records, devices SHOULD
            immediately query for their instance-specific record, without first
            querying for PTR records (Section 4.1 of <xref target="RFC6763"/>).
            Device MUST use their serial number (i.e., the same value as in the
            device identity certificate) for the "&lt;instance&gt;" portion of
            the service instance name (Section 4.1.1 of <xref target="RFC6763"/>).
            Device MUST only query for TXT records, in order to access the three
            bootstrapping artifacts defined in <xref target="artifacts"/>.</t>
  
            <t>When querying for device-independent DNS records, devices MUST only
            query for SRV records.  Multiple SRV records, each specifying an address,
            port, weight, and priority <xref target="RFC2782"/> is comparable to 
            an unsigned redirect information's list of bootstrap servers.  Note
            that a device-independent response is only able to encode unsigned
            data, since signed data necessitates the use of a device-specific
            ownership voucher.  Exclusive use of SRV records maximally leverages
            existing DNS standards for what is likely to be a common case when
            using a DNS server as a source of bootstrapping data.</t>
 
            <t>By example, assuming a device's serial number is "&lt;serial number&gt;",
            and that the domain discovered per Section 11 of <xref target="RFC6763"/>
            is "example.com", the device may issue the following sequence of DNS queries:
              <?rfc subcompact="yes"?>
              <list style="empty">
                <t>TXT in &lt;serial number&gt;._sztp._tcp.local.</t>
                <t>TXT in &lt;serial number&gt;._sztp._tcp.example.com.</t>
                <t>SRV in _sztp._tcp.local.</t>
                <t>SRV in _sztp._tcp.example.com.</t>
              </list>
              <?rfc subcompact="no"?>
            </t>

            <t>This document registers the service name "sztp" in
            <xref target="dns_srv"/>.</t>

          </section>

          <section title="DNS Response for Device-Specific Queries" toc="exclude">

            <t>For device-specific queries, the three bootstrapping artifacts defined
            in <xref target="artifacts"/> are encoded into the TXT records using 
            key/value pairs, as described in Section 6.3 in <xref target="RFC6763"/>.</t>
  
            <t>Artifact to TXT Record Mapping:
              <list style="hanging" hangIndent="6">
                <t hangText="   Conveyed Information:">Mapped to a TXT record
                having the key "ci" and the value being the binary
                artifact described in <xref target="conveyed-information"/>.</t>
                <t hangText="   Owner Certificate:">Mapped to a TXT record
                having the key "oc" and the value being the binary
                artifact described in <xref target="owner-certificate"/>.</t>
                <t hangText="   Ownership Voucher:">Mapped to a TXT record
                having the key "ov" and the value being the binary
                artifact described in <xref target="ownership-voucher"/>.</t>
              </list>
            </t>
  
            <t>Devices MUST ignore any other keys that may be returned.</t>
  
            <t>Note that, despite the name, TXT records can and SHOULD (per
            Section 6.5 of <xref target="RFC6763"/>) encode binary data.</t>
  
            <t>Following is an example of a device-specific response, as 
            it might be presented by a user-agent, containing signed data.
            This example assumes that the device's serial number is 
            "&lt;sn&gt;":
              <figure>
                <artwork><![CDATA[
  <sn>._sztp._tcp.example.com. 3600 IN TXT "ci=<binary data>"
  <sn>._sztp._tcp.example.com. 3600 IN TXT "oc=<binary data>"
  <sn>._sztp._tcp.example.com. 3600 IN TXT "ov=<binary data>"]]>
                </artwork>
              </figure>
            </t>

            <t>Note that, in the case that "zi" encodes unsigned data,
            the "oc" and "ov" keys would not be present in the response.</t>
          </section>
  
          <section title="DNS Response for Device-Independent Queries" toc="exclude">
            <t>For device-independent queries, the three bootstrapping
            artifacts defined in <xref target="artifacts"/> are encoded
            into the SVR records as follows.</t>
  
            <t>Artifact to SRV Record Mapping:
              <list style="hanging" hangIndent="6">
                <t hangText="   Conveyed Information:">This artifact is not supported
                directly.  Instead, the essence of unsigned redirect information is
                mapped to SVR records per <xref target="RFC2782"/>.</t>
                <t hangText="   Owner Certificate:">Not supported.  Device-independent
                responses are never encode signed data, and hence there is no need for
                an owner certificate artifact.</t>
                <t hangText="   Ownership Voucher:">Not supported.  Device-independent
                responses are never encode signed data, and hence there is no need for
                an ownership voucher artifact.</t>
              </list>
            </t>
  
            <t>Following is an example of a device-independent response, as
            it might be presented by a user-agent, containing (effectively)
            unsigned redirect information to four bootstrap servers:
              <figure>
                <artwork>
  _sztp._tcp.example.com. 1800 IN SRV 0 0 443 sztp1.example.com.
  _sztp._tcp.example.com. 1800 IN SRV 1 0 443 sztp2.example.com.
  _sztp._tcp.example.com. 1800 IN SRV 2 0 443 sztp3.example.com.
  _sztp._tcp.example.com. 1800 IN SRV 2 0 443 sztp4.example.com.
                </artwork>
              </figure>
            </t>

            <t>Note that, in this example, "sztp3" and "sztp4" have equal
            priority, and hence effectively represent a clustered pair
            of bootstrap servers.  While "sztp1" and "sztp2" only have
            a single SRV record each, it may be that the record points
            to a load-balancer fronting a cluster of bootstrap servers.</t>
          </section>

          <section title="Size of Signed Data" toc="exclude">

            <t>The signed data artifacts are large by DNS conventions.  In the
            smallest-footprint scenario, they are each a few kilobytes in size.
            However, onboarding information can easily be several kilobytes in
            size, and has the potential to be many kilobytes in size.</t>
  
            <t>All resource records, including TXT records, have an upper
            size limit of 65535 bytes, since "RDLENGTH" is a 16-bit field
            (Section 3.2.1 in <xref target="RFC1035"/>).  If it is ever 
            desired to encode onboarding information that exceeds this
            limit, the DNS records returned should instead encode redirect
            information, to direct the device to a bootstrap server from
            which the onboarding information can be obtained.</t>
  
            <t>Given the expected size of the TXT records, it is unlikely
            that signed data will fit into a UDP-based DNS packet, even
            with the EDNS(0) Extensions <xref target="RFC6891"/> enabled.
            Depending on content, signed data may also not fit into a
            multicast DNS packet, which bounds the size of the TXT records
            to 8900 bytes, per Section 6.1 in <xref target="RFC6763"/>.  Thus
            it is expected that DNS Transport over TCP <xref target="RFC7766"/>
            will be required in order to return signed data.</t>
          </section>

        </section> <!-- end DNS Server -->

        <section title="DHCP Server" anchor="dhcp-server">
          <t>A DHCP server MAY be used as a source of SZTP bootstrapping data.</t>

          <t>Using a DHCP server may be a compelling option for deployments having
          existing DHCP infrastructure, as it enables a touchless bootstrapping option
          that does not entail utilizing an Internet based resource hosted by a
          3rd-party.</t>

          <t>A DHCP server is an untrusted source of bootstrapping data.  Thus the
          information stored on the DHCP server either MUST be signed, or it MUST
          be information that can be processed provisionally (e.g., unsigned redirect
          information).</t>

          <t>However, unlike other sources of bootstrapping data described
          in this document, the DHCP protocol (especially DHCP for IPv4) is very
          limited in the amount of data that can be conveyed, to the extent that
          signed data cannot be communicated.  This means that only unsigned
          redirect information can be conveyed via DHCP.</t>

          <t>Since the redirect information is unsigned, it SHOULD NOT include the
          optional trust anchor certificate, as it takes up space in the DHCP
          message, and the device would have to discard it anyway.  For this
          reason, the DHCP options defined in <xref target="dhcp-options"/> do
          not enable the trust anchor certificate to be encoded.</t>

          <t>From an artifact perspective, the three artifacts defined in
          <xref target="artifacts"/> are mapped to the DHCP fields specified in
          <xref target="dhcp-options"/> as follows.</t>

          <t>Artifact to DHCP Option Fields Mapping:
            <list style="hanging" hangIndent="6">
              <t hangText="   Conveyed Information:">This artifact is not supported
              directly.  Instead, the essence of unsigned redirect information is
              mapped to the DHCP options described in <xref target="dhcp-options"/>.</t>
              <t hangText="   Owner Certificate:">Not supported.  There is not enough
              space in the DHCP packet to hold an owner certificate artifact.</t>
              <t hangText="   Ownership Voucher:">Not supported.  There is not enough
              space in the DHCP packet to hold an ownership voucher artifact.</t>
            </list>
          </t>
        </section>

        <section title="Bootstrap Server" anchor="bootstrap-server">
          <t>A bootstrap server MAY be used as a source of SZTP bootstrapping data.
          A bootstrap server is defined as a RESTCONF <xref target="RFC8040"/>
          server implementing the YANG module provided in <xref target="api"/>.</t>

          <t>Using a bootstrap server as a source of bootstrapping data is a compelling
          option as it MAY use transport-level security, obviating the need for signed
          data, which may be easier to deploy in some situations.</t>

          <t>Unlike any other source of bootstrapping data described in this document,
          a bootstrap server is not only a source of data, but it can also receive data
          from devices using the YANG-defined "report-progress" RPC defined in the YANG
          module (<xref target="yang-module"/>).  The "report-progress" RPC enables
          visibility into the bootstrapping process (e.g., warnings and errors), and
          provides potentially useful information upon completion (e.g., the device's
          SSH host-keys).</t>

          <t>A bootstrap server may be a trusted or an untrusted source of bootstrapping
          data, depending on if the device learned about the bootstrap server's trust
          anchor from a trusted source.  When a bootstrap server is trusted, the
          conveyed information returned from it MAY be signed.  When the bootstrap server is
          untrusted, the conveyed information either MUST be signed or MUST be information
          that can be processed provisionally (e.g., unsigned redirect information).</t>

          <t>From an artifact perspective, since a bootstrap server presents data
          conforming to a YANG data model, the bootstrapping artifacts need to be
          mapped to YANG nodes.  The three artifacts defined in <xref target="artifacts"/>
          are mapped to "output" nodes of the "get-bootstrapping-data" RPC defined
          in <xref target="yang-module"/> below.</t>

          <t>Artifact to Bootstrap Server Mapping:
            <list style="hanging" hangIndent="6">
              <t hangText="   Conveyed Information:">Mapped to the "conveyed-information"
              leaf in the output of the "get-bootstrapping-data" RPC.</t>
              <t hangText="   Owner Certificate:">Mapped to the "owner-certificate"
              leaf in the output of the "get-bootstrapping-data" RPC.</t>
              <t hangText="   Ownership Voucher:">Mapped to the "ownership-voucher"
              leaf in the output of the "get-bootstrapping-data" RPC.</t>
            </list>
          </t>

          <t>SZTP bootstrap servers have only two endpoints, one for the
          "get-bootstrapping-data" RPC and one for the "report-progress" RPC.
          These RPCs use the authenticated RESTCONF username to isolate the
          execution of the RPC from other devices.</t>

        </section>  <!-- end bootstrap server -->

      </section>




      <section title="Device Details" anchor="device-details">

          <t>Devices supporting the bootstrapping strategy described in this
          document MUST have the preconfigured state and bootstrapping logic
          described in the following sections.</t>

          <section title="Initial State" anchor="initial-state">
            <figure>
                <artwork><![CDATA[
+-------------------------------------------------------------+
|                           <device>                          |
|                                                             |
| +---------------------------------------------------------+ |
| |                   <read/write storage>                  | |
| |                                                         | |
| | 1. flag to enable SZTP bootstrapping set to "true"      | |
| +---------------------------------------------------------+ |
|                                                             |
| +---------------------------------------------------------+ |
| |                   <read-only storage>                   | |
| |                                                         | |
| | 2. TLS client cert & related intermediate certificates  | |
| | 3. list of trusted well-known bootstrap servers         | |
| | 4. list of trust anchor certs for bootstrap servers     | |
| | 5. list of trust anchor certs for ownership vouchers    | |
| +---------------------------------------------------------+ |
|                                                             |
|   +-----------------------------------------------------+   |
|   |                 <secure storage>                    |   |
|   |                                                     |   |
|   |  6. private key for TLS client certificate          |   |
|   |  7. private key for decrypting SZTP artifacts       |   |
|   +-----------------------------------------------------+   |
|                                                             |
+-------------------------------------------------------------+
]]></artwork>
            </figure>
            <t>Each numbered item below corresponds to a numbered item in the diagram above.
            <list style="numbers">

              <t>Devices MUST have a configurable variable that is used to enable/disable
              SZTP bootstrapping.  This variable MUST be enabled by default in
              order for SZTP bootstrapping to run when the device first powers on.
              Because it is a goal that the configuration installed by the bootstrapping
              process disables SZTP bootstrapping, and because the
              configuration may be merged into the existing configuration, using a
              configuration node that relies on presence is NOT RECOMMENDED, as it
              cannot be removed by the merging process.</t>

              <t>Devices that support loading bootstrapping data from bootstrap servers
              (see <xref target="bootstrap-server"/>) SHOULD possess a TLS-level client
              certificate and any intermediate certificates leading to the certificate's
              well-known trust-anchor.  The well-known trust anchor certificate may
              be an intermediate certificate or a self-signed root certificate.  To
              support devices not having a client certificate, devices MAY, alternatively
              or in addition to, identify and authenticate themselves to the bootstrap
              server using an HTTP authentication scheme, as allowed by Section 2.5 in
              <xref target="RFC8040"/>; however, this document does not define a
              mechanism for operator input enabling, for example, the entering of
              a password.</t>

              <t>Devices that support loading bootstrapping data from well-known
              bootstrap servers MUST possess a list of the well-known bootstrap servers.
              Consistent with redirect information (<xref target="redirect-information"/>,
              each bootstrap server can be identified by its hostname or IP address, and
              an optional port.</t>

              <t>Devices that support loading bootstrapping data from well-known
              bootstrap servers MUST also possess a list of trust anchor certificates
              that can be used to authenticate the well-known bootstrap servers.  For
              each trust anchor certificate, if it is not itself a self-signed root
              certificate, the device SHOULD also possess the chain of intermediate
              certificates leading up to and including the self-signed root certificate.</t>

              <t>Devices that support loading signed data (see <xref target="terminology"/>)
              MUST possess the trust anchor certificates for validating ownership vouchers.
              For each trust anchor certificate, if it is not itself a self-signed
              root certificate, the device SHOULD also possess the chain of intermediate
              certificates leading up to and including the self-signed root certificate.</t>

              <t>Devices that support using a TLS-level client certificate to identify
              and authenticate themselves to a bootstrap server MUST possess the
              private key that corresponds to the public key encoded in the TLS-level
              client certificate.  This private key SHOULD be securely stored, ideally
              in a cryptographic processor, such as a trusted platform module (TPM)
              chip.</t>

              <t>Devices that support decrypting SZTP artifacts MUST posses the
              private key that corresponds to the public key encoded in the secure
              device identity certificate used when encrypting the artifacts.  This
              private key SHOULD be securely stored, ideally in a cryptographic 
              processor, such as a trusted platform module (TPM) chip.  This private
              key MAY be the same as the one associated to the TLS-level client
              certificate used when connecting to bootstrap servers.</t>
            </list>
          </t>
          <t>A YANG module representing this data is provided in
          <xref target="device-model"/>.</t>

        </section>

        <section title="Boot Sequence" anchor="boot-sequence">
          <t>A device claiming to support the bootstrapping strategy defined in this
          document MUST support the boot sequence described in this section.</t>
          <t>
            <figure>
              <artwork><![CDATA[
    Power On
        |
        v                           No
 1. SZTP bootstrapping configured ------> Boot normally
        |
        | Yes
        v
 2. For each supported source of bootstrapping data,
    try to load bootstrapping data from the source
        |
        |
        v                               Yes
 3. Able to bootstrap from any source? -----> Run with new config
        |
        | No
        v
 4. Loop back to Step 1.


 Note: At any time, the device MAY be configured via an alternate
       provisioning mechanism (e.g., CLI).
]]></artwork>
            </figure>
          </t>

          <t>Each numbered item below corresponds to a numbered item in the diagram above.
            <list style="numbers">
              <t>When the device powers on, it first checks to see if SZTP bootstrapping
              is configured, as is expected to be the case for the device's preconfigured
              initial state.   If SZTP bootstrapping is not configured, then the device
              boots normally.</t>
              <t>The device iterates over its list of sources for
              bootstrapping data (<xref target="sources"/>).  Details for
              how to processes a source of bootstrapping data are provided
              in <xref target="processing-a-source"/>.</t>
              <t>If the device is able to bootstrap itself from any of
              the sources of bootstrapping data, it runs with the new
              bootstrapped configuration.</t>
              <t>Otherwise the device MUST loop back through the list of
              bootstrapping sources again.</t>
            </list>
          </t>
          <t>This document does not limit the simultaneous use of alternate
             provisioning mechanisms.  Such mechanisms may include, for instance,
             a command line interface (CLI), a web-based user interface, or
             even another bootstrapping protocol.  Regardless how it is
             configured, the configuration SHOULD unset the flag enabling
             SZTP bootstrapping discussed in <xref target="initial-state"/>.</t>
        </section>  <!-- end boot sequence -->

        <section title="Processing a Source of Bootstrapping Data" anchor="processing-a-source">
          <t>This section describes a recursive algorithm that devices can use to,
          ultimately, obtain onboarding information.  The algorithm is recursive
          because sources of bootstrapping data may return redirect information,
          which causes the algorithm to run again, for the newly discovered sources
          of bootstrapping data.  An expression that captures all possible
          successful sequences of bootstrapping data is: zero or more redirect
          information responses, followed by one onboarding information response.</t>

          <t>An important aspect of the algorithm is knowing when data needs to be
          signed or not.  The following figure provides a summary of options:
          <figure>
            <artwork><![CDATA[
                                 Untrusted Source  Trusted Source
    Kind of Bootstrapping Data     Can Provide?     Can Provide?

    Unsigned Redirect Info     :       Yes+             Yes
    Signed Redirect Info       :       Yes              Yes*
    Unsigned Onboarding Info   :        No              Yes
    Signed Onboarding Info     :       Yes              Yes*

    The '+' above denotes that the source redirected to MUST
    return signed data, or more unsigned redirect information.

    The '*' above denotes that, while possible, it is generally
    unnecessary for a trusted source to return signed data.
]]></artwork>
          </figure></t>

          <t>The recursive algorithm uses a conceptual global-scoped variable
          called "trust-state".  The trust-state variable is initialized to FALSE.
          The ultimate goal of this algorithm is for the device to process
          onboarding information (<xref target="onboarding-information"/>)
          while the trust-state variable is TRUE.</t>

          <t>If the source of bootstrapping data (<xref target="sources"/>) is a
          bootstrap server (<xref target="bootstrap-server"/>), and the device is
          able to authenticate the bootstrap server using X.509 certificate path
          validation (<xref target="RFC6125"/>, Section 6) to one of the device's
          preconfigured trust anchors, or to a trust anchor that it learned
          from a previous step, then the device MUST set trust-state to TRUE.</t>

          <t>When establishing a connection to a bootstrap server, whether
          trusted or untrusted, the device MUST identify and authenticate
          itself to the bootstrap server using a TLS-level client certificate
          and/or an HTTP authentication scheme, per Section 2.5 in 
          <xref target="RFC8040"/>.  If both authentication mechanisms
          are used, they MUST both identify the same serial number.</t>

          <t>When sending a client certificate, the device MUST also send all of
          the intermediate certificates leading up to, and optionally including,
          the client certificate's well-known trust anchor certificate.</t>

          <t>For any source of bootstrapping data (e.g., <xref target="sources"/>),
          if any artifact obtained is encrypted, the device MUST first decrypt it
          using the private key associated with the device certificate used to
          encrypt the artifact.</t>

          <t>If the conveyed information artifact is signed, and the device
          is able to validate the signed data using the algorithm described in
          <xref target="validating-signed-data"/>, then the device MUST set
          trust-state to TRUE; otherwise, if the device is unable to validate
          the signed data, the device MUST set trust-state to FALSE.  Note,
          this is worded to cover the special case when signed data is returned
          even from a trusted source of bootstrapping data.</t>

          <t>If the conveyed information artifact contains redirect information,
          the device MUST, within limits of how many recursive loops the device
          allows, process the redirect information as described in
          <xref target="process-redirect-information"/>.  Implementations MUST
          limit the maximum number of recursive redirects allowed; the maximum
          number of recursive redirects allowed SHOULD be no more than ten.
          This is the recursion step, it will cause the device to reenter this
          algorithm, but this time the data source will definitely be a bootstrap
          server, as redirect information is only able to redirect devices to
          bootstrap servers.</t>

          <t>If the conveyed information artifact contains onboarding information, and
          trust-state is FALSE, the device MUST exit the recursive algorithm (as
          this is not allowed, see the figure above), returning to the bootstrapping
          sequence described in <xref target="boot-sequence"/>.  Otherwise, the device
          MUST attempt to process the onboarding information as described in
          <xref target="process-onboarding-information"/>.  Whether the processing
          of the onboarding information succeeds or fails, the device MUST exit the
          recursive algorithm, returning to the bootstrapping sequence described
          in <xref target="boot-sequence"/>, the only difference being in how it
          responds to the "Able to bootstrap from any source?" conditional described
          in the figure in the section.</t>
        </section>

        <section title="Validating Signed Data" anchor="validating-signed-data">
          <t>Whenever a device is presented signed data, it MUST validate the
          signed data as described in this section.  This includes the case
          where the signed data is provided by a trusted source.</t>
          <t>Whenever there is signed data, the device MUST also be provided
          an ownership voucher and an owner certificate.  How all the needed
          artifacts are provided for each source of bootstrapping data is
          described in <xref target="sources"/>.</t>
          <t>In order to validate signed data, the device MUST first 
          authenticate the ownership voucher by validating its signature to one
          of its preconfigured trust anchors (see <xref target="initial-state"/>),
          which may entail using additional intermediate certificates attached
          to the ownership voucher.  If the device has an accurate clock,
          it MUST verify that the ownership voucher was created in the past
          (i.e., "created-on" &lt; now) and, if the "expires-on" leaf is present,
          the device MUST verify that the ownership voucher has not yet expired
          (i.e., now &lt; "expires-on").  The device MUST verify that the ownership
          voucher's "assertion" value is acceptable (e.g., some devices may only
          accept the assertion value "verified").  The device MUST verify that
          the ownership voucher specifies the device's serial number in the
          "serial-number" leaf.  If the "idevid-issuer" leaf is present, the
          device MUST verify that the value is set correctly.  If the authentication
          of the ownership voucher is successful, the device extracts the 
          "pinned-domain-cert" node, an X.509 certificate, that is
          needed to verify the owner certificate in the next step.</t>
          <t>The device MUST next authenticate the owner certificate by performing
          X.509 certificate path verification to the trusted certificate extracted
          from the ownership voucher's "pinned-domain-cert" node.  This verification
          may entail using additional intermediate certificates attached to the
          owner certificate artifact.  If the ownership voucher's
          "domain-cert-revocation-checks" node's value is set to "true", the device
          MUST verify the revocation status of the certificate chain used to sign
          the owner certificate and, if suitably-fresh revocation status is unattainable or
          if it is determined that a certificate has been revoked, the device
          MUST NOT validate the owner certificate.</t>
          <t>Finally, the device MUST verify that the conveyed information
          artifact was signed by the validated owner certificate.</t>
          <t>If any of these steps fail, the device MUST invalidate the
          signed data and not perform any subsequent steps.</t>
        </section>  <!-- end validating signed data -->

        <section title="Processing Redirect Information" anchor="process-redirect-information">
          <t>In order to process redirect information (<xref target="redirect-information"/>),
          the device MUST follow the steps presented in this section.</t>

          <t>Processing redirect information is straightforward; the device sequentially
          steps through the list of provided bootstrap servers until it can find one it
          can bootstrap from.</t>

          <t>If a hostname is provided, and the hostname's DNS resolution is to more
          than one IP address, the device MUST attempt to connect to all of the DNS
          resolved addresses at least once, before moving on to the next bootstrap
          server.  If the device is able to obtain bootstrapping data from any of the
          DNS resolved addresses, it MUST immediately process that data, without
          attempting to connect to any of the other DNS resolved addresses.</t>

          <t>If the redirect information is trusted (e.g., trust-state is TRUE), and the
          bootstrap server entry contains a trust anchor certificate, then the device MUST
          authenticate the specified bootstrap server's TLS server certificate
          using X.509 certificate path validation (<xref target="RFC6125"/>, Section 6)
          to the specified trust anchor.  If the bootstrap server entry does not contain
          a trust anchor certificate device, the device MUST establish a provisional
          connection to the bootstrap server (i.e., by blindly accepting its server
          certificate), and set trust-state to FALSE.</t>

          <t>If the redirect information is untrusted (e.g., trust-state is FALSE), the
          device MUST discard any trust anchors provided by the redirect information and
          establish a provisional connection to the bootstrap server (i.e., by blindly
          accepting its TLS server certificate).</t>
        </section>

        <section title="Processing Onboarding Information" anchor="process-onboarding-information">
          <t>In order to process onboarding information (<xref target="onboarding-information"/>),
          the device MUST follow the steps presented in this section.</t>

          <t>When processing onboarding information, the device MUST first process the
          boot image information (if any), then execute the pre-configuration script
          (if any), then commit the initial configuration (if any), and then execute
          the post-configuration script (if any), in that order.</t>

          <t>When the onboarding information is obtained from a trusted bootstrap server,
          the device MUST send the "bootstrap-initiated" progress report, and send either
          a terminating "boot-image-installed-rebooting", "bootstrap-complete", or error
          specific progress report.  If the bootstrap server's "get-bootstrapping-data"
          RPC-reply's "reporting-level" node is set to "verbose", the device MUST
          additionally send all appropriate non-terminating progress reports (e.g.,
          initiated, warning, complete, etc.).  Regardless of the reporting-level indicated
          by the bootstrap server, the device MAY send progress reports beyond the
          mandatory ones specified for the given reporting level.</t>

          <t>When the onboarding information is obtained from an untrusted bootstrap
          server, the device MUST NOT send any progress reports to the bootstrap server,
          even though the onboarding information was, necessarily, signed and authenticated.
          Please be aware that bootstrap servers are recommended to promote untrusted
          connections to trusted connections, in the last paragraph of Section 9.6, so
          as to, in part, be able to collect progress reports from devices.</t>
 
          <t>If the device encounters an error at any step, it MUST stop processing the
          onboarding information and return to the bootstrapping sequence described in
          <xref target="boot-sequence"/>. In the context of a recursive algorithm, the
          device MUST return to the enclosing loop, not back to the very beginning.
          Some state MAY be retained from the bootstrapping process (e.g., updated
          boot image, logs, remnants from a script, etc.).  However, the retained
          state MUST NOT be active in any way (e.g., no new configuration or running
          of software), and MUST NOT hinder the ability for the device to continue
          the bootstrapping sequence (i.e., process onboarding information from
          another bootstrap server).</t>

          <t>At this point, the specific ordered sequence of actions the device MUST
          perform is described.</t>

          <t>If the onboarding information is obtained from a trusted bootstrap server,
          the device MUST send a "bootstrap-initiated" progress report.  It is an error
          if the device does not receive back the "204 No Content" HTTP status line.
          If an error occurs, the device MUST try to send a "bootstrap-error" progress
          report before exiting.</t>

          <t>The device MUST parse the provided onboarding information document, to 
          extract values used in subsequent steps.  Whether using a stream-based parser
          or not, if there is an error when parsing the onboarding information, and the
          device is connected to a trusted bootstrap server, the device MUST try to send
          a "parsing-error" progress report before exiting.</t>

          <t>If boot image criteria are specified, the device MUST first determine if the
          boot image it is running satisfies the specified boot image criteria.  If the 
          device is already running the specified boot image, then it skips the remainder
          of this step.  If the device is not running the specified boot image, then it
          MUST download, verify, and install, in that order, the specified boot
          image, and then reboot.  If connected to a trusted bootstrap server, the
          device MAY try to send a "boot-image-mismatch" progress report.  To download
          the boot image, the device MUST only use the URIs supplied by the onboarding
          information.  To verify the boot image, the device MUST either use one of the
          verification fingerprints supplied by the onboarding information, or use a
          cryptographic signature embedded into the boot image itself using a mechanism
          not described by this document.  Before rebooting, if connected to a trusted
          bootstrap server, the device MUST try to send a "boot-image-installed-rebooting"
          progress report.  Upon rebooting, the bootstrapping process runs again, which
          will eventually come to this step again, but then the device will be running
          the specified boot image, and thus will move to processing the next step.  If
          an error occurs at any step while the device is connected to a trusted
          bootstrap server (i.e., before the reboot), the device MUST try to send
          a "boot-image-error" progress report before exiting.</t>

          <t>If a pre-configuration script has been specified, the device MUST execute the
          script, capture any output emitted from the script, and check if the script had
          any warnings or errors.  If an error occurs while the device is connected to a
          trusted bootstrap server, the device MUST try to send a "pre-script-error"
          progress report before exiting.</t>
 
          <t>If an initial configuration has been specified, the device MUST atomically
          commit the provided initial configuration, using the approach specified by the 
          "configuration-handling" leaf.  If an error occurs while the device is connected
          to a trusted bootstrap server, the device MUST try to send a "config-error"
          progress report before exiting.</t>

          <t>If a post-configuration script has been specified, the device MUST execute the
          script, capture any output emitted from the script, and check if the script had
          any warnings or errors. If an error occurs while the device is connected to a
          trusted bootstrap server, the device MUST try to send a "post-script-error"
          progress report before exiting.</t>

          <t>If the onboarding information was obtained from a trusted bootstrap server,
          and the result of the bootstrapping process did not disable the "flag to enable
          SZTP bootstrapping" described in <xref target="initial-state"/>, the device
          SHOULD send an "bootstrap-warning" progress report.</t>

          <t>If the onboarding information was obtained from a trusted bootstrap server,
          the device MUST send a "bootstrap-complete" progress report.  It is an error
          if the device does not receive back the "204 No Content" HTTP status line.
          If an error occurs, the device MUST try to send a "bootstrap-error" progress
          report before exiting.</t>

          <t>At this point, the device has completely processed the bootstrapping
          data.</t>

          <t>The device is now running its initial configuration.  Notably,
          if NETCONF Call Home or RESTCONF Call Home <xref target="RFC8071"/> is
          configured, the device initiates trying to establish the call home
          connections at this time.</t>

          <t>Implementation Notes:
           <list>
            <t>Implementations may vary in how to ensure no unwanted state is retained
            when an error occurs.</t>
            <t>Following are some guidelines for if the implementation chooses to undo
            previous steps:
              <list style="symbols">
                <t>When an error occurs, the device must rollback the current step and
                any previous steps.</t>
                <t>Most steps are atomic.  For example, the processing of a configuration
                is specified above as atomic, and the processing of scripts is similarly
                specified as atomic in the "ietf-sztp-conveyed-info" YANG module.</t>
                <t>In case the error occurs after the initial configuration was committed,
                the device must restore the configuration to the configuration that
                existed prior to the configuration being committed.</t>
                <t>In case the error occurs after a script had executed successfully,
                it may be helpful for the implementation to define scripts as being
                able to take a conceptual input parameter indicating that the script
                should remove its previously set state.</t>
              </list>
            </t>
           </list>
          </t>

        </section>
      </section>  <!-- end device details -->

      <section title="The Conveyed Information Data Model" anchor="zt-info-data-model">
        <t>This section defines a YANG 1.1 <xref target="RFC7950"/> module that is used to
        define the data model for the conveyed information artifact described in
        <xref target="conveyed-information"/>.  This data model uses the "yang-data"
        extension statement defined in <xref target="RFC8040"/>.
        Examples illustrating this data model are provided in
        <xref target="zt-info-data-model-examples"/>.</t>

        <section title="Data Model Overview">
          <t>The following tree diagram provides an overview of the data model for the
          conveyed information artifact.</t>
          <figure>
            <artwork name="ietf-sztp-conveyed-info-tree.txt"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ietf-sztp-conveyed-info-tree.txt)
]]></artwork>
          </figure>
        </section>

        <section title="Example Usage" anchor="zt-info-data-model-examples">

          <t>The following example illustrates how redirect information
          (<xref target="redirect-information"/>) can be encoded using JSON.</t>
          <figure>
            <artwork name="ex-file-redirect-information.json"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-file-redirect-information.json)
]]></artwork>
          </figure>

          <t>The following example illustrates how onboarding information
          (<xref target="onboarding-information"/>) can be encoded using JSON.</t>
          <figure>
            <artwork name="ex-file-onboarding-information.json"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-file-onboarding-information.json)
]]></artwork>
          </figure>
        </section>

        <section title="YANG Module" anchor="info-yang-module">
          <t>The conveyed information data model is defined
          by the YANG module presented in this section.</t>

          <t>This module uses data types defined in <xref target="RFC5280"/>,
          <xref target="RFC5652"/>, <xref target="RFC6234"/>, and
          <xref target="RFC6991"/>, an extension statement from
          <xref target="RFC8040"/>, and an
          encoding defined in <xref target="ITU.X690.2015"/>.</t>

          <figure>
            <artwork name="ietf-sztp-conveyed-info@YYYY-MM-DD.yang"><![CDATA[
<CODE BEGINS> file "ietf-sztp-conveyed-info@YYYY-MM-DD.yang"
INSERT_TEXT_FROM_FILE(ietf-sztp-conveyed-info@YYYY-MM-DD.yang)
<CODE ENDS>
]]></artwork>
          </figure>
        </section>

      </section>

      <section title="The SZTP Bootstrap Server API" anchor="api">

        <t>This section defines the API for bootstrap servers.  The API is
        defined as that produced by a RESTCONF <xref target="RFC8040"/>
        server that supports the YANG 1.1 <xref target="RFC7950"/> module
        defined in this section.</t>

        <section title="API Overview">
          <t>The following tree diagram provides an overview for the bootstrap server
          RESTCONF API.</t>
          <figure>
            <artwork name="ietf-sztp-bootstrap-server-tree.txt"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ietf-sztp-bootstrap-server-tree.txt)
]]></artwork>
          </figure>
        </section>

        <section title="Example Usage" anchor="api-examples">

          <t>This section presents three examples illustrating the bootstrap server's
          API.  Two examples are provided for the "get-bootstrapping-data" RPC (once
          to an untrusted bootstrap server, and again to a trusted bootstrap server),
          and one example for the "report-progress" RPC.</t>

          <t>The following example illustrates a device using the API to fetch its
          bootstrapping data from a untrusted bootstrap server.  In this example, the
          device sends the "signed-data-preferred" input parameter and receives signed
          data in the response.</t>
          <figure>
            <preamble>REQUEST</preamble>
            <artwork name="ex-api-get-bootstrap-data-rpc-untrusted.xml"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-api-get-bootstrap-data-rpc-untrusted.xml)
]]></artwork>
          </figure>
          <figure>
            <preamble>RESPONSE</preamble>
            <artwork name="ex-api-get-bootstrap-data-rpc-reply-untrusted.xml"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-api-get-bootstrap-data-rpc-reply-untrusted.xml)
]]></artwork>
          </figure>

          <t>The following example illustrates a device using the API to fetch its
          bootstrapping data from a trusted bootstrap server.  In this example, the
          device sends addition input parameters to the bootstrap server, which it
          may use when formulating its response to the device.</t>
          <figure>
            <preamble>REQUEST</preamble>
            <artwork name="ex-api-get-bootstrap-data-rpc-trusted.xml"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-api-get-bootstrap-data-rpc-trusted.xml)
]]></artwork>
          </figure>
          <figure>
            <preamble>RESPONSE</preamble>
            <artwork name="ex-api-get-bootstrap-data-rpc-reply-trusted.xml"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-api-get-bootstrap-data-rpc-reply-trusted.xml)
]]></artwork>
          </figure>
          <t>The following example illustrates a device using the API to post
          a progress report to a bootstrap server.  Illustrated below is
          the "bootstrap-complete" message, but the device may send other
          progress reports to the server while bootstrapping.  In this
          example, the device is sending both its SSH host keys and a TLS
          server certificate, which the bootstrap server may, for example,
          pass to an NMS, as discussed in <xref target="device-powers-on"/>.</t>

          <figure>
            <preamble>REQUEST</preamble>
            <artwork name=""><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-api-report-progress-rpc.xml)
]]></artwork>
          </figure>
          <figure>
            <preamble>RESPONSE</preamble>
            <artwork><![CDATA[
HTTP/1.1 204 No Content
Date: Sat, 31 Oct 2015 17:02:40 GMT
Server: example-server
]]></artwork>
          </figure>
        </section>  <!-- Example Usage -->

        <section title="YANG Module" anchor="yang-module">
          <t>The bootstrap server's device-facing API is normatively defined
          by the YANG module defined in this section.</t>

          <t>This module uses data types defined in <xref target="RFC4253"/>,
          <xref target="RFC5652"/>, <xref target="RFC5280"/>,
          <xref target="RFC6960"/>, and <xref target="RFC8366"/>, uses
          an encoding defined in <xref target="ITU.X690.2015"/>, and 
          makes a reference to <xref target="RFC4250"/> and 
          <xref target="RFC6187"/>.</t>
          <figure>
            <artwork name="ietf-sztp-bootstrap-server@YYYY-MM-DD.yang"><![CDATA[
<CODE BEGINS> file "ietf-sztp-bootstrap-server@YYYY-MM-DD.yang"
INSERT_TEXT_FROM_FILE(ietf-sztp-bootstrap-server@YYYY-MM-DD.yang)
<CODE ENDS>
]]></artwork>
          </figure>
        </section> <!-- YANG Module -->
      </section> <!-- The STZP Bootstrap Server API -->

      <section title="DHCP Options" anchor="dhcp-options">

        <t>This section defines two DHCP options, one for DHCPv4 and one for
        DHCPv6.  These two options are semantically the same, though syntactically
        different.</t>

        <section title="DHCPv4 SZTP Redirect Option">

        <t>The DHCPv4 SZTP Redirect Option is used to provision the client
          with one or more URIs for bootstrap servers that can be
          contacted to attempt further configuration.</t>

          <figure>
            <artwork><![CDATA[
   DHCPv4 SZTP Redirect Option

   0               1
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   |  option-code (143)  |   option-length  |
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   .                        .
   .   bootstrap-server-list (variable length)  .
   .                        .
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

   o option-code: OPTION_V4_SZTP_REDIRECT (143)
   o option-length: The option length in octets.
   o bootstrap-server-list: A list of servers for the
      client to attempt contacting, in order to obtain
      further bootstrapping data, in the format shown
      in Section 8.3.
]]></artwork>
          </figure>

          <t>DHCPv4 Client Behavior</t>
          <t>Clients MAY request the OPTION_V4_SZTP_REDIRECT by including its
          option code in the Parameter Request List (55) in DHCP request messages.</t>
          <t>On receipt of a DHCPv4 Reply message which contains the
          OPTION_V4_SZTP_REDIRECT, the client processes the response according
          to <xref target="process-redirect-information"/>, with the understanding
          that the "address" and "port" values are encoded in the URIs.</t>
          <t>Any invalid URI entries received in the uri-data field are ignored by
          the client. If OPTION_V4_SZTP_REDIRECT does not contain at least one
          valid URI entry in the uri-data field, then the client MUST discard the
          option.</t>

          <t>As the list of URIs may exceed the maximum allowed length of
            a single DHCPv4 option (255 octets), the client MUST implement
            <xref target="RFC3396"/>, allowing the URI list to be split
            across a number of OPTION_V4_SZTP_REDIRECT option
            instances.
          </t>

          <t>DHCPv4 Server Behavior</t>
          <t>The DHCPv4 server MAY include a single instance of Option
            OPTION_V4_SZTP_REDIRECT in DHCP messages it sends. Servers MUST
            NOT send more than one instance of the OPTION_V4_SZTP_REDIRECT option.
          </t>

          <t>The servers DHCP message MUST contain only a single instance of the
          OPTION_V4_SZTP_REDIRECTs 'bootstrap-server-list
          field. However, the list of URIs in this field may exceed the maximum
          allowed length of a single DHCPv4 option (per <xref target="RFC3396"/>).
          </t>

          <t>If the length of 'bootstrap-server-list is small enough to fit into
          a single instance of OPTION_V4_SZTP_REDIRECT,  the server MUST NOT
          send more than one instance of this option.</t>

          <t>If the length of the 'bootstrap-server-list field is too large to
          fit into a single option, then OPTION_V4_SZTP_REDIRECT MUST be
          split into multiple instances of the option according to the process
          described in <xref target="RFC3396"/>.</t>

        </section>

        <section title="DHCPv6 SZTP Redirect Option">

          <t>The DHCPv6 SZTP Redirect Option is used to provision the client with
          one or more URIs for bootstrap servers that can be contacted to
          attempt further configuration.</t>
          <figure>
            <artwork><![CDATA[
   DHCPv6 SZTP Redirect Option

   0          1          2          3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       option-code (136)      |     option-length    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   .          bootstrap-server-list (variable length)           .
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   o option-code: OPTION_V6_SZTP_REDIRECT (136)
   o option-length: The option length in octets.
   o bootstrap-server-list: A list of servers for the client to
     attempt contacting, in order to obtain further bootstrapping
     data, in the format shown in Section 8.3.
]]></artwork>
          </figure>

          <t>DHCPv6 Client Behavior</t>
          <t>Clients MAY request the OPTION_V6_SZTP_REDIRECT option, as defined
          in <xref target="RFC8415"/>, Sections 18.2.1, 18.2.2, 18.2.4, 18.2.5,
          18.2.6, and 21.7.  As a convenience to the reader, we mention here that
          the client includes requested option codes in the Option Request Option.</t>
          <t>On receipt of a DHCPv6 Reply message which contains the
          OPTION_V6_SZTP_REDIRECT, the client processes the response according
          to <xref target="process-redirect-information"/>, with the understanding
          that the "address" and "port" values are encoded in the URIs.</t>
          <t>Any invalid URI entries received in the uri-data field are ignored
          by the client. If OPTION_V6_SZTP_REDIRECT does not contain at least
          one valid URI entry in the uri-data field, then the client MUST discard
          the option.</t>

          <t>DHCPv6 Server Behavior</t>
          <t>Section 18.3 of <xref target="RFC8415"/> governs server
          operation inregard to option assignment. As a convenience to the
          reader, wemention here that the server will send a particular option
          code onlyif configured with specific values for that option code and
          if theclient requested it.</t>

          <t>Option OPTION_V6_SZTP_REDIRECT is a singleton.  Servers MUST NOT
           send more than one instance of the OPTION_V6_SZTP_REDIRECT
           option.</t>


        </section> <!-- DHCPv6 -->

        <section title="Common Field Encoding" anchor="common-field-encoding">
          <t>Both of the DHCPv4 and DHCPv6 options defined in this section encode
            a list of bootstrap server URIs.  The "URI" structure is a DHCP
            option that can contain multiple URIs (see <xref target="RFC7227"/>, 
            Section 5.7). Each URI entry in the bootstrap-server-list is 
            structured as follows:
          </t>

          <figure>
            <artwork><![CDATA[
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...-+-+-+-+-+-+-+
  |       uri-length              |          URI                  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...-+-+-+-+-+-+-+

  o uri-length: 2 octets long, specifies the length of the URI data.

  o URI: URI of SZTP bootstrap server.
]]></artwork>
          </figure>

          <t>The URI of the SZTP bootstrap server MUST use
          the "https" URI scheme defined in Section 2.7.2 of 
          <xref target="RFC7230"/>, and MUST be in form 
          "https://&lt;ip-address-or-hostname&gt;[:&lt;port&gt;]".</t>

        </section> <!-- common -->

      </section> <!-- DHCP -->


      <section title="Security Considerations" anchor="sec-con">
        <section title="Clock Sensitivity" anchor="clock-sens">
          <t>The solution in this document relies on TLS certificates,
          owner certificates, and ownership vouchers, all of which
          require an accurate clock in order to be processed
          correctly (e.g., to test validity dates and revocation
          status).  Implementations SHOULD ensure devices have an
          accurate clock when shipped from manufacturing facilities,
          and take steps to prevent clock tampering.</t>
          <t>If it is not possible to ensure clock accuracy, it is
          RECOMMENDED that implementations disable the aspects of the
          solution having clock sensitivity. In particular, such
          implementations should assume that TLS certificates,
          ownership vouchers, and owner certificates never expire
          and are not revokable.  From an ownership voucher
          perspective, manufacturers SHOULD issue a single
          ownership voucher for the lifetime of such devices.</t>
          <t>Implementations SHOULD NOT rely on NTP for time, as
          NTP is not a secure protocol at this time.  Note, there
          is an IETF work-in-progress to secure NTP 
          <xref target="I-D.ietf-ntp-using-nts-for-ntp"/>.</t>
        </section>
        <section title="Use of IDevID Certificates">
          <t>IDevID certificates, as defined in <xref target="Std-802.1AR-2009"/>,
          are RECOMMENDED, both for the TLS-level client certificate used
          by devices when connecting to a bootstrap server, as well as for
          the device identity certificate used by owners when encrypting
          the SZTP bootstrapping data artifacts.</t>
        </section>
        <section title="Immutable Storage for Trust Anchors">
          <t>Devices MUST ensure that all their trust anchor certificates,
          including those for connecting to bootstrap servers and verifying
          ownership vouchers, are protected from external modification.</t>
          <t>It may be necessary to update these certificates over time 
          (e.g., the manufacturer wants to delegate trust to a new CA).
          It is therefore expected that devices MAY update these trust
          anchors when needed through a verifiable process, such as a
          software upgrade using signed software images.</t>
        </section>
        <section title="Secure Storage for Long-lived Private Keys">
          <t>Manufacturer-generated device identifiers may have very long
          lifetimes.  For instance, <xref target="Std-802.1AR-2009"/>
          recommends using the "notAfter" value 99991231235959Z in IDevID
          certificates.  Given the long-lived nature of these private keys,
          it is paramount that they are stored so as to resist discovery,
          such as in a secure cryptographic processor, such as a trusted
          platform module (TPM) chip.</t>
        </section>
        <section title="Blindly Authenticating a Bootstrap Server">
          <t>This document allows a device to blindly authenticate a
          bootstrap server's TLS certificate.  It does so to allow
          for cases where the redirect information may be obtained
          in an unsecured manner, which is desirable to support
          in some cases.</t>
          <t>To compensate for this, this document requires that
          devices, when connected to an untrusted bootstrap server,
          assert that data downloaded from the server is signed.</t>
        </section>
        <section title="Disclosing Information to Untrusted Servers">
          <t>This document allows devices to establish connections to
          untrusted bootstrap servers.  However, since the bootstrap
          server is untrusted, it may be under the control of an
          adversary, and therefore devices SHOULD be cautious about
          the data they send to the bootstrap server in such cases.</t>
          <t>Devices send different data to bootstrap servers at each
          of the protocol layers TCP, TLS, HTTP, and RESTCONF.</t>
          <t>At the TCP protocol layer, devices may relay their IP address,
          subject to network translations.  Disclosure of this information
          is not considered a security risk.</t>
          <t>At the TLS protocol layer, devices may use a client certificate
          to identify and authenticate themselves to untrusted bootstrap
          servers.  At a minimum, the client certificate must disclose
          the device's serial number, and may disclose additional information
          such as the device's manufacturer, hardware model, public key, etc.
          Knowledge of this information may provide an adversary with details
          needed to launch an attack.  It is RECOMMENDED that secrecy of the
          network constituency is not relied on for security.</t>
          <t>At the HTTP protocol layer, devices may use an HTTP authentication
          scheme to identify and authenticate themselves to untrusted bootstrap
          servers.  At a minimum, the authentication scheme must disclose the
          device's serial number and, concerningly, may, depending on the
          authentication mechanism used, reveal a secret that is only supposed
          to be known to the device (e.g., a password).  Devices SHOULD NOT use
          an HTTP authentication scheme (e.g., HTTP Basic) with an untrusted
          bootstrap server that reveals a secret that is only supposed to be
          known to the device.</t>
          <t>At the RESTCONF protocol layer, devices use the "get-bootstrapping-data"
          RPC, but not the "report-progress" RPC, when connected to an untrusted
          bootstrap server.  The "get-bootstrapping-data" RPC allows additional
          input parameters to be passed to the bootstrap server (e.g., "os-name",
          "os-version", "hw-model").  It is RECOMMENDED that devices only pass
          the "signed-data-preferred" input parameter to an untrusted bootstrap
          server.  While it is okay for a bootstrap server to immediately
          return signed onboarding information, it is RECOMMENDED that
          bootstrap servers instead promote the untrusted connection to a
          trusted connection, as described in <xref target="untrust2trust"/>,
          thus enabling the device to use the "report-progress" RPC while
          processing the onboarding information.</t>
       </section>
        <section title="Sequencing Sources of Bootstrapping Data">
          <t>For devices supporting more than one source for bootstrapping
          data, no particular sequencing order has to be observed for
          security reasons, as the solution for each source is considered
          equally secure.  However, from a privacy perspective, it is
          RECOMMENDED that devices access local sources before accessing
          remote sources.</t>
        </section>
        <section title="Safety of Private Keys used for Trust">
          <t>The solution presented in this document enables bootstrapping
          data to be trusted in two ways, either through transport level
          security or through the signing of artifacts.</t>
          <t>When transport level security (i.e., a trusted bootstrap server)
          is used, the private key for the end-entity certificate must be
          online in order to establish the TLS connection.</t>
          <t>When artifacts are signed, the signing key is required to be
          online only when the bootstrap server is returning a dynamically
          generated signed-data response.  For instance, a bootstrap server,
          upon receiving the "signed-data-preferred" input parameter to the
          "get-bootstrapping-data" RPC, may dynamically generate a response
          that is signed.</t>
          <t>Bootstrap server administrators are RECOMMENDED to follow best
          practice to protect the private key used for any online operation.
          For instance, use of a hardware security module (HSM) is RECOMMENDED.
          If an HSM is not used, frequent private key refreshes are RECOMMENDED,
          assuming all bootstrapping devices have an accurate clock (see
          <xref target="clock-sens"/>).</t>
          <t>For best security, it is RECOMMENDED that owners only provide
          bootstrapping data that has been signed, using a protected private
          key, and encrypted, using the device's public key from its secure
          device identity certificate.</t>
        </section>
        <section title="Increased Reliance on Manufacturers">
          <t>The SZTP bootstrapping protocol presented in this document shifts
          some control of initial configuration away from the rightful owner of the
          device and towards the manufacturer and its delegates.</t>
          <t>The manufacturer maintains the list of well-known bootstrap servers
          its devices will trust.  By design, if no bootstrapping data is found via
          other methods first, the device will try to reach out to the well-known
          bootstrap servers.  There is no mechanism to prevent this from occurring
          other than by using an external firewall to block such connections.
          Concerns related to trusted bootstrap servers are discussed in 
          <xref target="seccon-trusted-bootstrap-servers"/>.</t>
          <t>Similarly, the manufacturer maintains the list of voucher signing
          authorities its devices will trust.  The voucher signing authorities
          issue the vouchers that enable a device to trust an owner's domain
          certificate.  It is vital that manufacturers ensure the integrity
          of these voucher signing authorities, so as to avoid incorrect
          assignments.</t>
          <t>Operators should be aware that this system assumes that they trust
          all the pre-configured bootstrap servers and voucher signing authorities
          designated by the manufacturers.  While operators may use points in
          the network to block access to the well-known bootstrap servers,
          operators cannot prevent voucher signing authorities from generating
          vouchers for their devices.</t>
        </section>
        <section title="Concerns with Trusted Bootstrap Servers"
                 anchor="seccon-trusted-bootstrap-servers">
          <t>Trusted bootstrap servers, whether well-known or discovered,
          have the potential to cause problems, such as the following.
            <list style="symbols">
              <t>A trusted bootstrap server that has been compromised may be
              modified to return unsigned data of any sort.  For instance, a
              bootstrap server that is only suppose to return redirect 
              information might be modified to return onboarding information.
              Similarly, a bootstrap server that is only supposed to return
              signed data, may be modified to return unsigned data.  In both
              cases, the device will accept the response, unaware that it
              wasn't supposed to be any different.  It is RECOMMENDED that
              maintainers of trusted bootstrap servers ensure that their
              systems are not easily compromised and, in case of compromise,
              have mechanisms in place to detect and remediate the compromise
              as expediently as possible.</t>
              <t>A trusted bootstrap server hosting either unsigned, or signed
              but not encrypted, data may disclose information to unwanted parties
              (e.g., an administrator of the bootstrap server).  This is a privacy
              issue only, but could reveal information that might be used in a
              subsequent attack.  Disclosure of redirect information has limited
              exposure (it is just a list of bootstrap servers), whereas disclosure
              of onboarding information could be highly revealing (e.g., network
              topology, firewall policies, etc.).  It is RECOMMENDED that operators
              encrypt the bootstrapping data when its contents are considered 
              sensitive, even to the point of hiding it from the administrators
              of the bootstrap server, which may be maintained by a 3rd-party.</t>
            </list>
          </t>
        </section>
        <section title="Validity Period for Conveyed Information">
          <t>The conveyed information artifact does not specify a validity period.  For
          instance, neither redirect information nor onboarding information
          enable "not-before" or "not-after" values to be specified, and
          neither artifact alone can be revoked.</t>

          <t>For unsigned data provided by an untrusted source of bootstrapping
          data, it is not meaningful to discuss its validity period when the
          information itself has no authenticity and may have come from anywhere.</t>

          <t>For unsigned data provided by a trusted source of bootstrapping
          data (i.e., a bootstrap server), the availability of the data
          is the only measure of it being current.  Since the untrusted data
          comes from a trusted source, its current availability is meaningful
          and, since bootstrap servers use TLS, the contents of the exchange
          cannot be modified or replayed.</t>

          <t>For signed data, whether provided by an untrusted or trusted
          source of bootstrapping data, the validity is constrained by
          the validity of the both the ownership voucher and owner
          certificate used to authenticate it.</t>
          
          <t>The ownership voucher's validity is primarily constrained by 
          the ownership voucher's "created-on" and "expires-on" nodes.  
          While <xref target="RFC8366"/> recommends short-lived vouchers
          (see Section 6.1), the "expires-on" node may be set to any point
          in the future, or omitted altogether to indicate that the voucher
          never expires.  The ownership voucher's validity is secondarily
          constrained by the manufacturer's PKI used to sign the voucher;
          whilst an ownership voucher cannot be revoked directly, the PKI
          used to sign it may be.</t>

          <t>The owner certificate's validity is primarily constrained by
          the X.509's validity field, the "notBefore" and "notAfter" values,
          as specified by the certificate authority that signed it.  The
          owner certificate's validity is secondarily constrained by the
          validity of the PKI used to sign the voucher.  Owner certificates
          may be revoked directly.</t>

          <t>For owners that wish to have maximum flexibility in their
          ability to specify and constrain the validity of signed data,
          it is RECOMMENDED that a unique owner certificate is created
          for each signed artifact.  Not only does this enable a
          validity period to be specified, for each artifact, but it
          also enables to the validity of each artifact to be revoked.</t>
        </section>
        <section title="Cascading Trust via Redirects">
          <t>Redirect Information (<xref target="redirect-information"/>),
          by design, instructs a bootstrapping device to initiate a HTTPS
          connection to the specified bootstrap servers.</t>
          <t>When the redirect information is trusted, the redirect
          information can encode a trust anchor certificate used by
          the device to authenticate the TLS end-entity certificate
          presented by each bootstrap server.</t>
          <t>As a result, any compromise in an interaction providing 
          redirect information may result in compromise of all
          subsequent interactions.</t>
        </section>
        <section title="Possible Reuse of Private Keys">
          <t>This document describes two uses for secure device identity
          certificates.</t>
          <t>The primary use is for when the device authenticates
          itself to a bootstrap server, using its private key for
          TLS-level client-certificate based authentication.</t>
          <t>A secondary use is for when the device needs to decrypt
          provided bootstrapping artifacts, using its private key
          to decrypt the data or, more precisely, per Section 6 in 
          <xref target="RFC5652"/>, decrypt a symmetric key used to
          decrypt the data.</t>
          <t>This document, in <xref target="artifact-encryption"/>
          allows for the possibility that the same secure device
          identity certificate is used for both uses, as 
          <xref target="Std-802.1AR-2009"/> states that a DevID
          certificate MAY have the "keyEncipherment" KeyUsage bit,
          in addition to the "digitalSignature" KeyUsage bit, set.</t>
          <t>While it is understood that it is generally frowned
          upon to reuse private keys, this document views such
          reuse acceptable as there are not any known ways to cause
          a signature made in one context to be (mis)interpreted
          as valid in the other context.</t>
        </section>
        <section title="Non-Issue with Encrypting Signed Artifacts">
          <t>This document specifies the encryption of signed objects,
          as opposed to the signing of encrypted objects, as might
          be expected given well-publicized oracle attacks (e.g., the
          padding oracle attack).</t>
          <t>This document does not view such attacks as feasible in
          the context of the solution because the decrypted text never
          leaves the device.</t>
        </section>
        <section title="The &quot;ietf-sztp-conveyed-info&quot; YANG Module">
          <t>The ietf-sztp-conveyed-info module defined in this document
          defines a data structure that is always wrapped by a CMS structure.
          When accessed by a secure mechanism (e.g., protected by TLS), then the
          CMS structure may be unsigned.  However, when accessed by an insecure
          mechanism (e.g., removable storage device), then the CMS structure
          must be signed, in order for the device to trust it.</t>
          <t>Implementations should be aware that signed bootstrapping data
          only protects the data from modification, and that the contents are still
          visible to others.  This doesn't affect security so much as privacy.
          That the contents may be read by unintended parties when accessed by
          insecure mechanisms is considered next.</t>
          <t>The ietf-sztp-conveyed-info module defines a top-level "choice"
          statement that declares the contents are either "redirect-information"
          or "onboarding-information".  Each of these two cases are now considered.</t>
          <t>When the content of the CMS structure is redirect-information,
          an observer can learn about the bootstrap servers the device is being
          directed to, their IP addresses or hostnames, ports, and trust anchor
          certificates.  Knowledge of this information could provide an observer
          some insight into a network's inner structure.</t>
          <t>When the content of the CMS structure is onboarding information,
          an observer could learn considerable information about how the device
          is to be provisioned.  This information includes the operating system
          version, initial configuration, and script contents.  This information
          should be considered sensitive and precautions should be taken to 
          protect it (e.g., encrypt the artifact using the device's public key).</t>
        </section>
        <section title="The &quot;ietf-sztp-bootstrap-server&quot; YANG Module">
          <t>The ietf-sztp-bootstrap-server module defined in this document
          specifies an API for a RESTCONF <xref target="RFC8040"/>.  The lowest
          RESTCONF layer is HTTPS, and the mandatory-to-implement secure transport
          is TLS <xref target="RFC8446"/>.</t>
          <t>The NETCONF Access Control Model (NACM) <xref target="RFC8341"/>
          provides the means to restrict access for particular users
          to a preconfigured subset of all available protocol operations
          and content.</t>
          <t>This module presents no data nodes (only RPCs).  There is no need
          to discuss the sensitivity of data nodes.</t>
          <t>This module defines two RPC operations that may be considered
          sensitive in some network environments.  These are the operations
          and their sensitivity/vulnerability:
            <list style="hanging" hangIndent="4">
              <t hangText="get-bootstrapping-data:">This RPC is used by devices
              to obtain their bootstrapping data.  By design, each device, as
              identified by its authentication credentials (e.g. client 
              certificate), can only obtain its own data.  NACM is not needed
              to further constrain access to this RPC.</t>
              <t hangText="report-progress:">This RPC is used by devices
              to report their bootstrapping progress.  By design, each device,
              as identified by its authentication credentials (e.g. client 
              certificate), can only report data for itself.  NACM is not
              needed to further constrain access to this RPC.</t>
            </list>
          </t>
        </section>
      </section>  <!-- end Security Considerations -->

      <section title="IANA Considerations" anchor="iana-considerations">
        <section title="The IETF XML Registry">
          <t>This document registers two URIs in the "ns" subregistry of
          the IETF XML Registry <xref target="RFC3688"/> maintained at 
          https://www.iana.org/assignments/xml-registry/xml-registry.xhtml#ns.  
          Following the format in <xref target="RFC3688"/>, the following
          registrations are requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
URI: urn:ietf:params:xml:ns:yang:ietf-sztp-conveyed-info
Registrant Contact: The NETCONF WG of the IETF.
XML: N/A, the requested URI is an XML namespace.

URI: urn:ietf:params:xml:ns:yang:ietf-sztp-bootstrap-server
Registrant Contact: The NETCONF WG of the IETF.
XML: N/A, the requested URI is an XML namespace.
]]></artwork>
            </figure>
          </t>
        </section>
        <section title="The YANG Module Names Registry">
          <t>This document registers two YANG modules in the
          YANG Module Names registry <xref target="RFC6020"/> maintained at
          https://www.iana.org/assignments/yang-parameters/yang-parameters.xhtml.
          Following the format defined in <xref target="RFC6020"/>, the below
          registrations are requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
name:      ietf-sztp-conveyed-info
namespace: urn:ietf:params:xml:ns:yang:ietf-sztp-conveyed-info
prefix:    sztp-info
reference: RFC XXXX

name:      ietf-sztp-bootstrap-server
namespace: urn:ietf:params:xml:ns:yang:ietf-sztp-bootstrap-server
prefix:    sztp-svr
reference: RFC XXXX
]]></artwork>
          </figure>
        </t>
        </section>
        <section title="The SMI Security for S/MIME CMS Content Type Registry" anchor="cms_cts">
          <t>This document registers two SMI security codes in the "SMI Security for
          S/MIME CMS Content Type" registry (1.2.840.113549.1.9.16.1) maintained at
          https://www.iana.org/assignments/smi-numbers/smi-numbers.xhtml#security-smime-1.
          Following the format used in Section 3.4 of <xref target="RFC7107"/>, the
          below registrations are requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
Decimal   Description                  References
-------   --------------------------   ----------
TBD1      id-ct-sztpConveyedInfoXML    [RFCXXXX]
TBD2      id-ct-sztpConveyedInfoJSON   [RFCXXXX]
]]></artwork>
          </figure>
        </t>
        <t>id-ct-sztpConveyedInfoXML indicates that the "conveyed-information"
        is encoded using XML.  id-ct-sztpConveyedInfoJSON indicates that the
        "conveyed-information" is encoded using JSON.</t>
        </section>
        <section title="The BOOTP Manufacturer Extensions and DHCP Options Registry">
          <t>This document registers one DHCP code point in the "BOOTP Manufacturer
          Extensions and DHCP Options" registry maintained at
          http://www.iana.org/assignments/bootp-dhcp-parameters.  Following the
          format used by other registrations, the below registration is requested:</t>
          <t>
            <figure>
              <artwork>
Tag:         143
Name:        OPTION_V4_SZTP_REDIRECT
Data Length: N
Meaning:     This option provides a list of URIs
             for SZTP bootstrap servers
Reference:   [RFCXXXX]
              </artwork>
            </figure>
          </t>
          <t>Note: this request is to make permanent a previously registered
          early code point allocation.</t>
        </section>
        <section title="The Dynamic Host Configuration Protocol for IPv6 (DHCPv6) Registry">
          <t>This document registers one DHCP code point in "Option Codes" subregistry
          of the "Dynamic Host Configuration Protocol for IPv6 (DHCPv6)" registry 
          maintained at http://www.iana.org/assignments/dhcpv6-parameters.  Following the
          format used by other registrations, the below registration is requested:</t>
          <t>
            <figure>
              <artwork>
Value:            136
Description:      OPTION_V6_SZTP_REDIRECT
Client ORO:       Yes
Singleton Option: Yes
Reference:        [RFCXXXX]
              </artwork>
            </figure>
          </t>
          <t>Note: this request is to make permanent a previously registered
          early code point allocation.</t>
        </section>
        <section title="The Service Name and Transport Protocol Port Number Registry" anchor="dns_srv">
          <t>This document registers one service name in the Service Name and
          Transport Protocol Port Number Registry <xref target="RFC6335"/> maintained at
          https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml.
          Following the format defined in Section 8.1.1 of <xref target="RFC6335"/>, the
          below registration is requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
Service Name:            sztp
Transport Protocol(s):   TCP
Assignee:                IESG <iesg@ietf.org>
Contact:                 IETF Chair <chair@ietf.org>
Description:             This service name is used to construct the
                         SRV service label "_sztp" for discovering
                         SZTP bootstrap servers.
Reference:               [RFCXXXX]
Port Number:             N/A
Service Code:            N/A
Known Unauthorized Uses: N/A
Assignment Notes:        This protocol uses HTTPS as a substrate.
]]></artwork>
            </figure>
          </t>
        </section>
      </section>

    </middle>

    <back>
      <references title="Normative References">
        <?rfc include="reference.RFC.1035.xml"?>
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.2782.xml"?>
        <?rfc include="reference.RFC.5652.xml"?>
        <?rfc include="reference.RFC.8415.xml"?>
        <?rfc include="reference.RFC.3396.xml"?>
        <?rfc include="reference.RFC.4253.xml"?>
        <?rfc include="reference.RFC.5280.xml"?>
        <?rfc include="reference.RFC.6020.xml"?>
        <?rfc include="reference.RFC.6125.xml"?>
        <?rfc include="reference.RFC.6762.xml"?>
        <?rfc include="reference.RFC.6763.xml"?>
        <?rfc include="reference.RFC.6991.xml"?>
        <?rfc include="reference.RFC.7227.xml"?>
        <?rfc include="reference.RFC.7230.xml"?>
        <?rfc include="reference.RFC.7950.xml"?>
        <?rfc include="reference.RFC.8040.xml"?>
        <?rfc include="reference.RFC.8174.xml"?>
        <?rfc include="reference.RFC.8366.xml"?>

        <!-- THE FOLLOWING LINE DOESN'T RESOLVE FOR SOME REASON:
             <?rfc include="_reference.ITU.X690.2015.xml"?> -->
        <!-- THE FOLLOWING IS COPYIED FROM RFC 8366 -->
        <reference anchor="ITU.X690.2015" target="https://www.itu.int/rec/T-REC-X.690/">
          <front>
            <title>Information Technology - ASN.1 encoding rules: Specification of Basic
            Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished
            Encoding Rules (DER)</title>
            <author>
              <organization>International Telecommunication Union</organization>
            </author>
            <date month="August" year="2015" />
          </front>
          <seriesInfo name="ITU-T Recommendation X.690," value="ISO/IEC 8825-1" />
	</reference>

        <reference anchor="Std-802.1AR-2009" target="http://standards.ieee.org/findstds/standard/802.1AR-2009.html">
          <front>
            <title>IEEE Standard for Local and metropolitan area networks - Secure Device Identity</title>
            <author fullname="WG802.1 - Higher Layer LAN Protocols Working Group">
               <organization>IEEE SA-Standards Board</organization>
            </author>
            <date month="December" year="2009"/>
          </front>
        </reference>
      </references>

      <references title="Informative References">
        <?rfc include="reference.RFC.3688.xml"?>
        <?rfc include="reference.RFC.4250.xml"?>
        <?rfc include="reference.RFC.6187.xml"?>
        <?rfc include="reference.RFC.6234.xml"?>
        <?rfc include="reference.RFC.6241.xml"?>
        <?rfc include="reference.RFC.6335.xml"?>
        <?rfc include="reference.RFC.6891.xml"?>
        <?rfc include="reference.RFC.6960.xml"?>
        <?rfc include="reference.RFC.6698.xml"?>
        <?rfc include="reference.RFC.7107.xml"?>
        <?rfc include="reference.RFC.7766.xml"?>
        <?rfc include="reference.RFC.8071.xml"?>
        <?rfc include="reference.RFC.8340.xml"?>
        <?rfc include="reference.RFC.8341.xml"?>
        <?rfc include="reference.RFC.8446.xml"?>
        <?rfc include="reference.I-D.ietf-netconf-crypto-types"?>
        <?rfc include="reference.I-D.ietf-netconf-trust-anchors"?>
        <?rfc include="reference.I-D.ietf-ntp-using-nts-for-ntp"?>
      </references>


      <section title="Example Device Data Model" anchor="device-model">

        <t>This section defines a non-normative data model that 
        enables the configuration of SZTP bootstrapping and
        discovery of what parameters are used by a device's bootstrapping logic.</t>

        <section title="Data Model Overview">
          <t>The following tree diagram provides an overview for the SZTP
          device data model.</t>
          <figure>
            <artwork name="example-device-data-model-tree.txt"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/example-device-data-model-tree.txt)
]]></artwork>
          </figure>
          <t>In the above diagram, notice that there is only one configurable node
          "enabled".  The expectation is that this node would be set to "true" in
          device's factory default configuration and that it would either be set
          to "false" or deleted when the SZTP bootstrapping is longer needed.</t>
        </section>

        <section title="Example Usage" anchor="device-example">
          <t>Following is an instance example for this data model.</t>
          <figure>
            <artwork name="ex-api-device-model.xml"><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-api-device-model.xml)
]]></artwork>
          </figure>
        </section>  <!-- Example Usage -->

        <section title="YANG Module" anchor="device-yang-module">
          <t>The device model is defined by the YANG module
          defined in this section.</t>

          <t>This module uses data types defined in <xref target="RFC6991"/>,
          <xref target="I-D.ietf-netconf-crypto-types"/>, and
          <xref target="I-D.ietf-netconf-trust-anchors"/>.</t>
          <figure>
            <artwork name="example-device-data-model@YYYY-MM-DD.yang"><![CDATA[
INSERT_TEXT_FROM_FILE(example-device-data-model@YYYY-MM-DD.yang)
]]></artwork>
          </figure>
        </section> <!-- YANG Module -->
      </section> <!-- Example Device Data Model -->


      <section title="Promoting a Connection from Untrusted to Trusted" anchor="untrust2trust">
        <t>The following diagram illustrates a sequence of
        bootstrapping activities that promote an untrusted
        connection to a bootstrap server to a trusted connection
        to the same bootstrap server.  This enables a device
        to limit the amount of information it might disclose
        to an adversary hosting an untrusted bootstrap server.</t>
        <t><figure>
          <artwork><![CDATA[
                                                      +----------+
                                                      |Deployment|
                                                      | Specific |
+------+                                              |Bootstrap |
|Device|                                              |  Server  |
+------+                                              +----------+
   |                                                        |
   | 1. "HTTPS" Request ("signed-data-preferred", nonce)    |
   |------------------------------------------------------->|
   | 2. "HTTPS" Response (signed redirect information)      |
   |<-------------------------------------------------------|
   |                                                        |
   |                                                        |
   | 3. HTTPS Request (os-name=xyz, os-version=123, etc.)   |
   |------------------------------------------------------->|
   | 4. HTTPS Response (unsigned onboarding information     |
   |<-------------------------------------------------------|
   |                                                        |
]]></artwork>
        </figure></t>
        <t>The interactions in the above diagram are described below.</t>
        <t><list style="numbers">
          <t>The device initiates an untrusted connection to a bootstrap
          server, as is indicated by putting "HTTPS" in double quotes
          above.  It is still an HTTPS connection, but the device is
          unable to authenticate the bootstrap server's TLS certificate.
          Because the device is unable to trust the bootstrap server, it
          sends the "signed-data-preferred" input parameter, and optionally
          also the "nonce" input parameter, in the "get-bootstrapping-data"
          RPC.  The "signed-data-preferred" parameter informs the
          bootstrap server that the device does not trust it and may
          be holding back some additional input parameters from the
          server (e.g., other input parameters, progress reports, etc.).
          The "nonce" input parameter enables the bootstrap server to
          dynamically obtain an ownership voucher from a MASA, which
          may be important for devices that do not have a reliable clock.</t>
          <t>The bootstrap server, seeing the "signed-data-preferred"
          input parameter, knows that it can either send unsigned
          redirect information or signed data of any type.  But, in
          this case, the bootstrap server has the ability to sign
          data and chooses to respond with signed redirect information,
          not signed onboarding information as might be expected,
          securely redirecting the device back to it again.  Not
          displayed but, if the "nonce" input parameter was passed,
          the bootstrap server could dynamically connect to a 
          download a voucher from the MASA having the nonce value
          in it.  Details regarding a protocol enabling this integration
          is outside the scope of this document.</t>
          <t>Upon validating the signed redirect information, the
          device establishes a secure connection to the bootstrap
          server.  Unbeknownst to the device, it is the same bootstrap
          server it was connected to previously but, because the device
          is able to authenticate the bootstrap server this time, it sends its
          normal "get-bootstrapping-data" request (i.e., with additional
          input parameters) as well as its progress reports (not depicted).</t>
          <t>This time, because the "signed-data-preferred" parameter was
          not passed, having access to all of the device's input parameters,
          the bootstrap server returns, in this example, unsigned onboarding
          information to the device.  Note also that, because the bootstrap
          server is now trusted, the device will send progress reports to
          the server.</t>
        </list></t>
      </section>
      <section title="Workflow Overview" anchor="workflow-overview">

        <t>The solution presented in this document is conceptualized
        to be composed of the non-normative workflows described in this section.
        Implementation details are expected to vary.  Each diagram is followed
        by a detailed description of the steps presented in the diagram, with
        further explanation on how implementations may vary.</t>

        <section title="Enrollment and Ordering Devices" anchor="onboarding-and-ordering">
          <t>The following diagram illustrates key interactions that may occur from when a
          prospective owner enrolls in a manufacturer's SZTP program to when the
          manufacturer ships devices for an order placed by the prospective owner.</t>
          <t>
            <figure>
              <artwork><![CDATA[
                               +-----------+
+------------+                 |Prospective|                    +---+
|Manufacturer|                 |   Owner   |                    |NMS|
+------------+                 +-----------+                    +---+
      |                              |                            |
      |                              |                            |
      |  1. initiate enrollment      |                            |
      #<-----------------------------|                            |
      #                              |                            |
      #                              |                            |
      #     IDevID trust anchor      |                            |
      #----------------------------->#  set IDevID trust anchor   |
      #                              #--------------------------->|
      #                              |                            |
      #     bootstrap server         |                            |
      #     account credentials      |                            |
      #----------------------------->#  set credentials           |
      |                              #--------------------------->|
      |                              |                            |
      |                              |                            |
      |  2. set owner certificate trust anchor                    |
      |<----------------------------------------------------------|
      |                              |                            |
      |                              |                            |
      |  3. place device order       |                            |
      |<-----------------------------#  model devices             |
      |                              #--------------------------->|
      |                              |                            |
      |  4. ship devices and send    |                            |
      |     device identifiers and   |                            |
      |     ownership vouchers       |                            |
      |----------------------------->#  set device identifiers    |
      |                              #  and ownership vouchers    |
      |                              #--------------------------->|
      |                              |                            |
  ]]></artwork>
            </figure>
          </t>
          <t>Each numbered item below corresponds to a numbered item
          in the diagram above.
            <list style="numbers">
              <t>A prospective owner of a manufacturer's devices initiates an
              enrollment process with the manufacturer.  This process includes
              the following:
              <list style="symbols">
                <t>Regardless how the prospective owner intends to bootstrap their devices,
                they will always obtain from the manufacturer the trust anchor
                certificate for the IDevID certificates.  This certificate will
                is installed on the prospective owner's NMS so that the NMS can
                authenticate the IDevID certificates when they are presented to
                subsequent steps.</t>
                <t>If the manufacturer hosts an Internet based bootstrap server (e.g., a
                redirect server) such as described in <xref target="bootstrap-server"/>,
                then credentials necessary to configure the bootstrap server would be
                provided to the prospective owner.  If the bootstrap server is
                configurable through an API (outside the scope of this document), then
                the credentials might be installed on the prospective owner's NMS so
                that the NMS can subsequently configure the manufacturer-hosted
                bootstrap server directly.</t>
              </list></t>
              <t>If the manufacturer's devices are able to validate signed data
              (<xref target="validating-signed-data"/>), and assuming that the
              prospective owner's NMS is able to prepare and sign the bootstrapping
              data itself, the prospective owner's NMS might set a trust anchor
              certificate onto the manufacturer's bootstrap server, using the
              credentials provided in the previous step.  This certificate is the
              trust anchor certificate that the prospective owner would like the
              manufacturer to place into the ownership vouchers it generates, thereby
              enabling devices to trust the owner's owner certificate.  How this trust
              anchor certificate is used to enable devices to validate signed bootstrapping
              data is described in <xref target="validating-signed-data"/>.</t>
              <t>Some time later, the prospective owner places an order
              with the manufacturer, perhaps with a special
              flag checked for SZTP handling.  At this time, or
              perhaps before placing the order, the owner may model
              the devices in their NMS, creating virtual objects for the
              devices with no real-world device associations.  For instance
              the model can be used to simulate the device's location in the
              network and the configuration it should have when fully
              operational.</t>
              <t>When the manufacturer fulfills the order, shipping
              the devices to their intended locations, they may notify the owner
              of the devices' serial numbers and shipping destinations, which
              the owner may use to stage the network for when the devices power
              on.  Additionally,  the manufacturer may send one or more ownership
              vouchers, cryptographically assigning ownership of those devices to
              the owner.  The owner may set this information on their NMS, perhaps
              binding specific modeled devices to the serial numbers and ownership
              vouchers.</t>
            </list>
          </t>
        </section>


        <section title="Owner Stages the Network for Bootstrap">
          <t>The following diagram illustrates how an owner might stage the
          network for bootstrapping devices.</t>
          <t>
            <figure>
              <artwork><![CDATA[
            +----------+ +------------+
            |Deployment| |Manufacturer| +------+ +------+
            | Specific | |   Hosted   | | Local| | Local| +---------+
      +---+ |Bootstrap | | Bootstrap  | |  DNS | | DHCP | |Removable|
      |NMS| |  Server  | |   Server   | |Server| |Server| | Storage |
      +---+ +----------+ +------------+ +------+ +------+ +---------+
        |        |             |            |        |         |
1.      |        |             |            |        |         |
activate|        |             |            |        |         |
modeled |        |             |            |        |         |
device  |        |             |            |        |         |
------->|        |             |            |        |         |
        | 2. (optional)        |            |        |         |
        |    configure         |            |        |         |
        |    bootstrap         |            |        |         |
        |    server            |            |        |         |
        |------->|             |            |        |         |
        |        |             |            |        |         |
        | 3. (optional) configure           |        |         |
        |    bootstrap server  |            |        |         |
        |--------------------->|            |        |         |
        |        |             |            |        |         |
        |        |             |            |        |         |
        | 4. (optional) configure DNS server|        |         |
        |---------------------------------->|        |         |
        |        |             |            |        |         |
        |        |             |            |        |         |
        | 5. (optional) configure DHCP server        |         |
        |------------------------------------------->|         |
        |        |             |            |        |         |
        |        |             |            |        |         |
        | 6. (optional) store bootstrapping artifacts on media |
        |----------------------------------------------------->|
        |        |             |            |        |         |
        |        |             |            |        |         |
  ]]></artwork>
            </figure>
          </t>

          <t>Each numbered item below corresponds to a numbered item
          in the diagram above.
            <list style="numbers">
              <t>Having previously modeled the devices, including setting their
              fully operational configurations and associating device serial
              numbers and (optionally) ownership vouchers, the owner might "activate" one or
              more modeled devices.  That is, the owner tells the NMS to perform
              the steps necessary to prepare for when the real-world devices
              power up and initiate the bootstrapping process.  Note that,
              in some deployments, this step might be combined with the last step
              from the previous workflow.  Here it is depicted that an NMS performs
              the steps, but they may be performed manually or through some other
              mechanism.</t>
              <t>If it is desired to use a deployment-specific bootstrap server,
              it must be configured to provide the bootstrapping data for
              the specific devices.   Configuring the bootstrap server may occur
              via a programmatic API not defined by this document.  Illustrated
              here as an external component, the bootstrap server may be
              implemented as an internal component of the NMS itself.</t>
              <t>If it is desired to use a manufacturer hosted bootstrap
              server, it must be configured to provide the bootstrapping data
              for the specific devices.  The configuration must be either redirect or
              onboarding information.  That is, either the manufacturer hosted bootstrap
              server will redirect the device to another bootstrap server, or provide
              the device with the onboarding information itself.  The types of
              bootstrapping data the manufacturer hosted bootstrap server
              supports may vary by implementation; some implementations may only
              support redirect information, or only support onboarding information,
              or support both redirect and onboarding information.  Configuring the
              bootstrap server may occur via a programmatic API not defined by this
              document.</t>
              <t>If it is desired to use a DNS server to supply bootstrapping
              data, a DNS server needs to be configured.  If multicast
              DNS-SD is desired, then the DNS server must reside on the local network,
              otherwise the DNS server may reside on a remote network.  Please see
              <xref target="dns-server"/> for more information about how to
              configure DNS servers.  Configuring the DNS server may occur via
              a programmatic API not defined by this document.</t>
              <t>If it is desired to use a DHCP server to supply bootstrapping
              data, a DHCP server needs to be configured.  The DHCP server may
              be accessed directly or via a DHCP relay.  Please see
              <xref target="dhcp-server"/> for more information about how to
              configure DHCP servers.  Configuring the DHCP server may occur
              via a programmatic API not defined by this document.</t>
              <t>If it is desired to use a removable storage device (e.g., USB flash
              drive) to supply bootstrapping data, the data would need
              to be placed onto it.  Please see <xref target="removable-storage"/>
              for more information about how to configure a removable storage device.</t>
            </list>
          </t>
        </section>

        <section title="Device Powers On" anchor="device-powers-on">
          <t>The following diagram illustrates the sequence of activities
          that occur when a device powers on.
            <figure>
              <artwork><![CDATA[
                                                  +----------+
                                   +-----------+  |Deployment|
                                   | Source of |  | Specific |
+------+                           | Bootstrap |  |Bootstrap |  +---+
|Device|                           |   Data    |  |  Server  |  |NMS|
+------+                           +-----------+  +----------+  +---+
   |                                     |              |         |
   |                                     |              |         |
   | 1. if SZTP bootstrap service        |              |         |
   |    is not enabled, then exit.       |              |         |
   |                                     |              |         |
   | 2. for each source supported, check |              |         |
   |    for bootstrapping data.          |              |         |
   |------------------------------------>|              |         |
   |                                     |              |         |
   | 3. if onboarding information found, |              |         |
   |    initialize self and, only if     |              |         |
   |    source is a trusted bootstrap    |              |         |
   |    server, send progress reports.   |              |         |
   |------------------------------------>#              |         |
   |                                     # webhook      |         |
   |                                     #----------------------->|
   |                                                    |         |
   | 4. else if redirect-information found, for each    |         |
   |    bootstrap server specified, check for data.     |         |
   |-+------------------------------------------------->|         |
   | |                                                  |         |
   | | if more redirect-information is found, recurse   |         |
   | | (not depicted), else if onboarding information   |         |
   | | found, initialize self and post progress reports |         |
   | +------------------------------------------------->#         |
   |                                                    # webhook |
   |                                                    #-------->|
   |
   | 5. retry sources and/or wait for manual provisioning.
   |
  ]]></artwork>
            </figure>
          </t>
          <t>The interactions in the above diagram are described below.
            <list style="numbers">
              <t>Upon power being applied, the device checks to see if SZTP
              bootstrapping is configured, such as must be the case when running its
              "factory default" configuration.  If SZTP bootstrapping is
              not configured, then the bootstrapping logic exits and none of the
              following interactions occur.</t>
              <t>For each source of bootstrapping data the device supports, preferably
              in order of closeness to the device (e.g., removable storage before
              Internet based servers), the device checks to see if there is any
              bootstrapping data for it there.</t>
              <t>If onboarding information is found, the device initializes
              itself accordingly (e.g., installing a boot-image and committing an
              initial configuration).  If the source is a bootstrap server, and the
              bootstrap server can be trusted (i.e., TLS-level authentication), the
              device also sends progress reports to the bootstrap server.
                <list style="symbols">
                  <t>The contents of the initial configuration should configure
                  an administrator account on the device (e.g., username, SSH public
                  key, etc.), and should configure the device either to listen for
                  NETCONF or RESTCONF connections or to initiate call home connections
                  <xref target="RFC8071"/>, and should disable the SZTP
                  bootstrapping service (e.g., the "enabled" leaf in data model
                  presented in <xref target="device-model"/>).</t>
                  <t>If the bootstrap server supports forwarding device progress reports
                  to external systems (e.g., via a webhook), a "bootstrap-complete"
                  progress report (<xref target="yang-module"/>) informs the external
                  system to know when it can, for instance, initiate a connection to
                  the device.  To support this scenario further, the "bootstrap-complete"
                  progress report may also relay the device's SSH host keys and/or TLS
                  certificates, with which the external system can use to authenticate
                  subsequent connections to the device.</t>
                </list>
              If the device successfully completes the bootstrapping process,
              it exits the bootstrapping logic without considering any additional
              sources of bootstrapping data.
              </t>

              <t>Otherwise, if redirect information is found, the device iterates
              through the list of specified bootstrap servers, checking to see if
              the bootstrap server has bootstrapping data for the device.  If the bootstrap server
              returns more redirect information, then the device processes it recursively.
              Otherwise, if the bootstrap server returns onboarding information,
              the device processes it following the description provided in (3) above.</t>

              <t>After having tried all supported sources of bootstrapping data, the
              device may retry again all the sources and/or provide manageability
              interfaces for manual configuration (e.g., CLI, HTTP, NETCONF, etc.).
              If manual configuration is allowed, and such configuration is provided,
              the configuration should also disable the SZTP bootstrapping service,
              as the need for bootstrapping would no longer be present.</t>
            </list>
          </t>
        </section>
      </section>
      <section title="Change Log">
        <section title="ID to 00">
          <t>
          <list style="symbols">
            <t>Major structural update; the essence is the same.
            Most every section was rewritten to some degree.</t>
            <t>Added a Use Cases section</t>
            <t>Added diagrams for "Actors and Roles" and
            "NMS Precondition" sections, and greatly improved
            the "Device Boot Sequence" diagram</t>
            <t>Removed support for physical presence or any
            ability for configlets to not be signed.</t>
            <t>Defined the Conveyed Information DHCP option</t>
            <t>Added an ability for devices to also download
            images from configuration servers</t>
            <t>Added an ability for configlets to be encrypted</t>
            <t>Now configuration servers only have to support
            HTTP/S - no other schemes possible</t>
          </list>
          </t>
        </section>
        <section title="00 to 01">
          <t>
          <list style="symbols">
            <t>Added boot-image and validate-owner annotations
               to the "Actors and Roles" diagram.</t>
            <t>Fixed 2nd paragraph in section 7.1 to reflect
               current use of anyxml.</t>
            <t>Added encrypted and signed-encrypted examples</t>
            <t>Replaced YANG module with XSD schema</t>
            <t>Added IANA request for the Conveyed Information DHCP Option</t>
            <t>Added IANA request for media types for boot-image and configuration</t>
          </list>
          </t>
        </section>
        <section title="01 to 02">
          <t>
          <list style="symbols">
            <t>Replaced the need for a configuration signer with the
            ability for each NMS to be able to sign its own configurations,
            using manufacturer signed ownership vouchers and owner certificates.</t>
            <t>Renamed configuration server to bootstrap server, a more
            representative name given the information devices download from it.</t>
            <t>Replaced the concept of a configlet by defining a southbound
            interface for the bootstrap server using YANG.</t>
            <t>Removed the IANA request for the boot-image and configuration
            media types</t>
          </list>
          </t>
        </section>
        <section title="02 to 03">
          <t>
          <list style="symbols">
            <t>Minor update, mostly just to add an Editor's Note to show how this
            draft might integrate with the draft-pritikin-anima-bootstrapping-keyinfra.</t>
          </list>
          </t>
        </section>
        <section title="03 to 04">
          <t>
          <list style="symbols">
            <t>Major update formally introducing unsigned data and support for
            Internet-based redirect servers.</t>
            <t>Added many terms to Terminology section.</t>
            <t>Added all new "Guiding Principles" section.</t>
            <t>Added all new "Sources for Bootstrapping Data" section.</t>
            <t>Rewrote the "Interactions" section and renamed it "Workflow Overview".</t>
          </list>
          </t>
        </section>
        <section title="04 to 05">
          <t>
          <list style="symbols">
            <t>Semi-major update, refactoring the document into more logical parts</t>
            <t>Created new section for information types</t>
            <t>Added support for DNS servers</t>
            <t>Now allows provisional TLS connections</t>
            <t>Bootstrapping data now supports scripts</t>
            <t>Device Details section overhauled</t>
            <t>Security Considerations expanded</t>
            <t>Filled in enumerations for notification types</t>
           </list>
          </t>
        </section>
        <section title="05 to 06">
          <t>
          <list style="symbols">
            <t>Minor update</t>
            <t>Added many Normative and Informative references.</t>
            <t>Added new section Other Considerations.</t>
          </list>
          </t>
        </section>
        <section title="06 to 07">
          <t>
          <list style="symbols">
            <t>Minor update</t>
            <t>Added an Editorial Note section for RFC Editor.</t>
            <t>Updated the IANA Considerations section.</t>
          </list>
          </t>
        </section>
        <section title="07 to 08">
          <t>
          <list style="symbols">
            <t>Minor update</t>
            <t>Updated to reflect review from Michael Richardson.</t>
          </list>
          </t>
        </section>
        <section title="08 to 09">
          <t>
          <list style="symbols">
            <t>Added in missing "Signature" artifact example.</t>
            <t>Added recommendation for manufacturers to use interoperable
            formats and file naming conventions for removable storage devices.</t>
            <t>Added configuration-handling leaf to guide if config should be
            merged, replaced, or processed like an edit-config/yang-patch document.</t>
            <t>Added a pre-configuration script, in addition to the
            post-configuration script from -05 (issue #15).</t>
          </list>
          </t>
        </section>
        <section title="09 to 10">
          <t>
          <list style="symbols">
            <t>Factored ownership voucher and voucher revocation to a
            separate document: draft-kwatsen-netconf-voucher. (issue #11)</t>
            <t>Removed &lt;configuration-handling&gt; options "edit-config" and
            "yang-patch". (issue #12)</t>
            <t>Defined how a signature over signed-data returned from a
            bootstrap server is processed. (issue #13)</t>
            <t>Added recommendation for removable storage devices to use
            open/standard file systems when possible.  (issue #14)</t>
            <t>Replaced notifications "script-[warning/error]" with
            "[pre/post]-script-[warning/error]". (goes with issue #15)</t>
            <t>switched owner-certificate to be encoded using the PKCS #7
            format. (issue #16)</t>
            <t>Replaced md5/sha1 with sha256 inside a choice statement, for
            future extensibility. (issue #17)</t>
            <t>A ton of editorial changes, as I went thru the entire draft
            with a fine-toothed comb.</t>
          </list>
          </t>
        </section>
        <section title="10 to 11">
          <t>
          <list style="symbols">
            <t>fixed yang validation issues found by IETFYANGPageCompilation.
            note: these issues were NOT found by pyang --ietf or by the
            submission-time validator...</t>
            <t>fixed a typo in the yang module, someone the config false statement
            was removed.</t>
          </list>
          </t>
        </section>
        <section title="11 to 12">
          <t>
          <list style="symbols">
            <t>fixed typo that prevented Appendix B from loading the
            examples correctly.</t>
            <t>fixed more yang validation issues found by
            IETFYANGPageCompilation.  note: again, these issues were
            NOT found by pyang --ietf or by the submission-time
            validator...</t>
            <t>updated a few of the notification enumerations to be
            more consistent with the other enumerations (following the
            warning/error pattern).</t>
            <t>updated the information-type artifact to state how it is
            encoded, matching the language that was in Appendix B.</t>
          </list>
          </t>
        </section>
        <section title="12 to 13">
          <t>
          <list style="symbols">
            <t>defined a standalone artifact to encode the old information-type
            into a PKCS #7 structure.</t>
            <t>standalone information artifact hardcodes JSON encoding (to
            match the voucher draft).</t>
            <t>combined the information and signature PKCS #7 structures into a
            single PKCS #7 structure.</t>
            <t>moved the certificate-revocations into the owner-certificate's
            PKCS #7 structure.</t>
            <t>eliminated support for voucher-revocations, to reflect the
            voucher-draft's switch from revocations to renewals.</t>
          </list>
          </t>
        </section>
        <section title="13 to 14">
          <t>
          <list style="symbols">
            <t>Renamed "bootstrap information" to "onboarding information".</t>
            <t>Rewrote DHCP sections to address the packet-size limitation
            issue, as discussed in Chicago.</t>
            <t>Added Ian as an author for his text-contributions to the
            DHCP sections.</t>
            <t>Removed the Guiding Principles section.</t>
          </list>
          </t>
        </section>
        <section title="14 to 15">
          <t>
          <list style="symbols">
            <t>Renamed action "notification" to "update-progress" and, likewise
            "notification-type" to "update-type".</t>
            <t>Updated examples to use "base64encodedvalue==" for binary values.</t>
            <t>Greatly simplified the "Artifact Groupings" section, and
               moved it as a subsection to the "Artifacts" section.</t>
            <t>Moved the "Workflow Overview" section to the Appendix.</t>
            <t>Renamed "bootstrap information" to "update information".</t>
            <t>Removed "Other Considerations" section.</t>
            <t>Tons of editorial updates.</t>
          </list>
          </t>
        </section>
        <section title="15 to 16">
          <t>
            <list style="symbols">
              <t>tweaked language to refer to "initial state" rather than "factory
              default configuration", so as accommodate white-box scenarios.</t>
              <t>added a paragraph to Intro regarding how the solution primarily regards
              physical machines, but could be extended to VMs by a future document.</t>
              <t>added a pointer to the Workflow Overview section (recently moved to
              the Appendix) to the Intro.</t>
              <t>added a note that, in order to simplify the verification process,
              the "Conveyed Information" PKCS #7 structure MUST also contain the
              signing X.509 certificate.</t>
              <t>noted that the owner certificate's must either have no Key Usage or
              the Key Usage must set the "digitalSignature" bit.</t>
              <t>noted that the owner certificate's subject and subjectAltName values
              are not constrained.</t>
              <t>moved/consolidated some text from the Artifacts section down to the
              Device Details section.</t>
              <t>tightened up some ambiguous language, for instance, by referring to
              specific leaf names in the Voucher artifact.</t>
              <t>reverted a previously overzealous s/unique-id/serial-number/ change.</t>
              <t>modified language for when ZTP runs from when factory-default config
              is running to when ZTP is configured, which the factory-defaults should set .</t>
            </list>
          </t>
        </section>
        <section title="16 to 17">
          <t>
            <list style="symbols">
              <t>Added an example for how to promote an untrusted connection to a
              trusted connection.</t>
              <t>Added a "query parameters" section defining some parameters enabling
              scenarios raised in last call.</t>
              <t>Added a "Disclosing Information to Untrusted Servers" section to
              the Security Considerations.</t>
            </list>
          </t>
        </section>
        <section title="17 to 18">
          <t>
            <list style="symbols">
              <t>Added Security Considerations for each YANG module.</t>
              <t>Reverted back to the device always sending its DevID cert.</t>
              <t>Moved data tree to "get-bootstrapping-data" RPC.</t>
              <t>Moved the "update-progress" action to a "report-progress" RPC.</t>
              <t>Added an "signed-data-preferred" parameter to "get-bootstrapping-data" RPC.</t>
              <t>Added the "ietf-zerotouch-device" module.</t>
              <t>Lots of small updates.</t>
            </list>
          </t>
        </section>
        <section title="18 to 19">
          <t>
            <list style="symbols">
              <t>Fixed "must" expressions, by converting "choice" to a "list" of
              "image-verification", each of which now points to a base identity
              called "hash-algorithm".  There's just one algorithm currently
              defined (sha-256).  Wish there was a standard crypto module that
              could identify such identities.</t>
            </list>
          </t>
        </section>
        <section title="19 to 20">
          <t>
            <list style="symbols">
              <t>Now references I-D.ietf-netmod-yang-tree-diagrams.</t>
              <t>Fixed tree-diagrams in Section 2 to always reflect
              current YANG (now they are now dynamically generated).</t>
              <t>The "redirect-information" container's "trust-anchor"
              is now a CMS structure that can contain a chain of
              certificates, rather than a single certificate.</t>
              <t>The "onboarding-information" container's support
              for image verification reworked to be extensible.</t>
              <t>Added a reference to the "Device Details" section to
              the new example-device-data-model module.</t>
              <t>Clarified that the device must always pass its IDevID
              certificate, even for untrusted bootstrap servers.</t>
              <t>Fixed the description statement for the "script" typedef
              to refer to the [pre/post]-script-[warning/error] enums,
              rather than the legacy script-[warning/error] enums.</t>
              <t>For the get-bootstrapping-data RPC's input, removed
              the "remote-id" and "circuit-id" fields, and added a
              "hw-model" field.</t>
              <t>Improved DHCP error handling text.</t>
              <t>Added MUST requirement for DHCPv6 client and server
              implementing <xref target="RFC3396"/> to handle URI lists
              longer than 255 octets.</t>
              <t>Changed the "configuration" value in onboarding-information
              to be type "binary" instead of "anydata".</t>
              <t>Moved everything from PKCS#7 to CMS (this shows up
              as a big change).</t>
              <t>Added the early code point allocation assignments for the
              DHCP Options in the IANA Considerations section, and updated
              the RFC Editor note accordingly.</t>
              <t>Added RFC Editor request to replace the assigned values for
              the CMS content types.</t>
              <t>Relaxed auth requirements from device needing to always
              send IDevID cert to device needing to always send authentication
              credentials, as this better matches what RFC 8040 Section 2.5 says.</t>
              <t>Moved normative module "ietf-zerotouch-device" to non-normative
              module "example-device-data-model".</t>
              <t>Updated Title, Abstract, and Introduction per discussion on list.</t>
            </list>
          </t>
        </section>
        <section title="20 to 21">
          <t>
            <list style="symbols">
              <t>Now any of the three artifact can be encrypted.</t>
              <t>Fixed some line-too-long issues.</t>
            </list>
          </t>
        </section>
        <section title="21 to 22">
          <t>
            <list style="symbols">
              <t>Removed specifics around how scripts indicate warnings
                 or errors and how scripts emit output.</t>
              <t>Moved the SZTP Device Data Model section to
                 the Appendix.</t>
              <t>Modified the YANG module in the SZTP Device Data
                 Model section to reflect the latest trust-anchors and
                 keystore drafts.</t>
              <t>Modified types in other YANG modules to more closely
                 emulate what is in draft-ietf-netconf-crypto-types.</t>
            </list>
          </t>
        </section>
        <section title="22 to 23">
          <t>
            <list style="symbols">
              <t>Rewrote section 5.6 (processing onboboarding information)
              to be clearer about error handling and retained state.
              Specifically:
                <list style="symbols">
                  <t>Clarified that a script, upon having an error, must
                     gracefully exit, cleaning up any state that might hinder
                     subsequent executions.</t>
                  <t>Added ability for scripts to be executed again with a
                     flag enabling them to clean up state from a previous
                     execution.</t>
                  <t>Clarified that the conifguration commit is atomic.</t>
                  <t>Clarified that any error encountered after committing the
                     configuration (e.g., in the "post-configuration-script")
                     must rollback the configuration to the previous
                     configuration.</t>
                  <t>Clarified that failure to successfully deliver the
                     "bootstrap-initiated" and "bootstrap-complete" progress
                     types must be treated as an error.</t>
                  <t>Clarified that "return to bootstrapping sequence" is to be
                     interpreted in the recursive context.  Meaning that the
                     device rolls-back one loop, rather than start over from
                     scratch.</t>
                </list>
              </t>
              <t>Changed how a device verifies a boot-image from just "MUST
                 match one of the supplied fingerprints" to also allow for
                 the verification to use an cryptographic signature embedded
                 into the image itself.</t>
              <t>Added more "progress-type" enums for visibility reasons, 
                 enabling more strongly-typed debug information to be sent
                 to the bootstrap server.</t>
              <t>Added Security Considerations based on early SecDir review.</t>
              <t>Added recommendation for device to send warning if the 
                 initial config does not disable the bootstrapping process.</t>
            </list>
          </t>
        </section>
        <section title="23 to 24">
          <t>
            <list style="symbols">
              <t>Follow-ups from SecDir and Shepherd.</t>
              <t>Added "boot-image-complete" enumeration.</t>
            </list>
          </t>
        </section>
        <section title="24 to 25">
          <t>
            <list style="symbols">
              <t>Removed remaining old "bootstrapping information" term usage.</t>
              <t>Fixed DHCP Option length definition.</t>
              <t>Added reference to RFC 6187.</t>
            </list>
          </t>
        </section>
        <section title="25 to 26">
          <t>
            <list style="symbols">
              <t>Updated URI structure text (sec 8.3) and added norm. ref to RFC7230
              reflecting Alexey Melnikov's comment.</t>
              <t>Added IANA registration for the 'zerotouch' service, per IESG
                 review from Adam Roach.</t>
              <t>Clarified device's looping behavior and support for alternative
                 provisioning mechanisms, per IESG review from Mirja Khlewind.</t>
              <t>Updated "ietf-sztp-bootstrap-server:ssh-host-key" from
                 leaf-list to list, per IESG review from Benjamin Kaduk.</t>
              <t>Added option size text to DHCPv4 option size to address
                 Suresh Krishnan's IESG review discuss point.</t>
              <t>Updated RFC3315 to RFC8415 and associated section references.</t>
              <t>Revamped the DNS Server section, after digging into Alexey
                 Melnikov comment.</t>
              <t>Fixed IETF terminology template section in both YANG modules.</t>
            </list>
          </t>
        </section>
        <section title="26 to 27">
          <t>Added Security Consideration for cascading trust via redirects.</t>
          <t>Modified the get-bootstrapping-data RPC's "nonce" input parameter
          to being a minimum of 16-bytes (used to be 8-bytes).</t>
          <t>Added Security Consideration regarding possible reuse of device's
          private key.</t>
          <t>Added Security Consideration regarding use of sign-then-encrypt.</t>
          <t>Renamed "Zero Touch"/"zerotouch" throughout.  Now uses "SZTP"
          when referring to the draft/solution, and "conveyed" when referring
          to the bootstrapping artifact.</t>
          <t>Added missing text for "encrypted unsigned conveyed information"
          case.</t>
        </section>
      </section>

      <section title="Acknowledgements" numbered="no">
        <t>The authors would like to thank for following for
        lively discussions on list and in the halls (ordered
        by last name):
        Michael Behringer,
        Dean Bogdanovic,
        Martin Bjorklund,
        Joe Clarke,
        Toerless Eckert,
        Stephen Farrell,
        Stephen Hanna,
        Wes Hardaker,
        David Harrington,
        Mirja Khlewind,
        Radek Krejci,
        Suresh Krishnan,
        Benjamin Kaduk,
        David Mandelberg,
        Alexey Melnikov,
        Russ Mundy,
        Reinaldo Penno,
        Randy Presuhn,
        Max Pritikin,
        Michael Richardson,
        Adam Roach,
        Phil Shafer,
        Juergen Schoenwaelder.</t>

        <t>Special thanks goes to Steve Hanna, Russ Mundy, and
        Wes Hardaker for brainstorming the original I-D's solution
        during the IETF 87 meeting in Berlin.</t>
      </section>
    </back>
</rfc>
